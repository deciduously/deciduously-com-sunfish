{#  This file was auto-generated by build.rs #}
{% extends "skel.html" %}
{% block title %}Procedural Melody Generation in Rust{% endblock %}
{% block content %}<main><h2>Teaching Numbers How To Sing</h2>
<blockquote>
<p>Everything is music. When I go home, I throw knickers in the oven and it's music. Crash, boom, bang!</p>
</blockquote>
<p><em>- <a href="https://en.wikipedia.org/wiki/Winona_Ryder">Winona Ryder</a> as <a href="https://en.wikipedia.org/wiki/Bj%C3%B6rk">Björk</a> on <a href="https://en.wikipedia.org/wiki/Saturday_Night_Live">SNL</a>'s <a href="https://en.wikipedia.org/wiki/Celebrity_Jeopardy!_(Saturday_Night_Live)">Celebrity Rock 'N' Roll Jeopardy!</a> - <a href="https://en.wikipedia.org/wiki/2002">2002</a> - <a href="https://youtu.be/R3V94ZtmdbQ?t=190">YouTube</a></em></p>
<p>In this <a href="(https://en.wikipedia.org/wiki/Blog)">post</a>, we'll <a href="https://en.wikipedia.org/wiki/Throwing">throw</a> something <a href="https://en.wikipedia.org/wiki/Random_number_generation">random</a> into, <a href="https://en.wikipedia.org/wiki/Well">well</a>, a <a href="https://en.wikipedia.org/wiki/Mathematics">math</a>-<a href="https://en.wikipedia.org/wiki/Subroutine">oven</a> and <a href="https://en.wikipedia.org/wiki/Viola"><em>viola</em></a>, <a href="https://en.wikipedia.org/wiki/Music">music</a>!  We'll just skip the <a href="https://en.wikipedia.org/wiki/Crash_(computing)">crash</a>.</p>
<p>In other words, we're going to teach our <a href="https://en.wikipedia.org/wiki/Personal_computer">computers</a> to <a href="https://en.wikipedia.org/wiki/Singing">&quot;sing&quot;</a> using <a href="https://en.wikipedia.org/wiki/Programming_idiom">idiomatic</a> <a href="https://en.wikipedia.org/wiki/Rust_(programming_language)">Rust</a>, backed by a little light <a href="https://en.wikipedia.org/wiki/Physics">physics</a> and <a href="https://en.wikipedia.org/wiki/Music_theory">music theory</a>.</p>
<p>The <a href="https://en.wikipedia.org/wiki/One-liner_program">one-liner</a> in the cover image <a href="https://en.wikipedia.org/wiki/Procedural_generation">procedurally generates</a> a <a href="https://en.wikipedia.org/wiki/Melody">melody</a> using <a href="https://en.wikipedia.org/wiki/Unix_philosophy">tools assumed to be present</a> on a standard <a href="https://en.wikipedia.org/wiki/Desktop_computer">desktop</a> <a href="https://en.wikipedia.org/wiki/Linux_distribution">Linux distribution</a> like <a href="https://en.wikipedia.org/wiki/Ubuntu">Ubuntu</a>.  The melody produced will be composed of notes along a single <a href="https://en.wikipedia.org/wiki/Octave">octave</a> in a hardcoded <a href="https://en.wikipedia.org/wiki/Key_(music)">key</a> (<a href="https://en.wikipedia.org/wiki/A_major">A major</a>):</p>
<p>{% youtube uLhQQSKhTok %}</p>
<p>By the end of this post our program will:</p>
<ol>
<li>Support <a href="https://en.wikipedia.org/wiki/86_(number)">86</a> different <a href="https://en.wikipedia.org/wiki/Key_signature">key signatures</a> with <a href="https://en.wikipedia.org/wiki/Music_and_mathematics">minimal effort</a>.</li>
<li>Support a full <a href="https://en.wikipedia.org/wiki/108_(number)">108</a>-key extended <a href="https://en.wikipedia.org/wiki/Piano">piano</a> <a href="https://en.wikipedia.org/wiki/Musical_keyboard">keyboard</a>, allowing the user to pick a range.</li>
<li>Produce any arbitrary <a href="https://en.wikipedia.org/wiki/Musical_tone">tone</a> we ask for.</li>
<li>Compile and run on <a href="https://en.wikipedia.org/wiki/Microsoft_Windows">Windows</a>, <a href="https://en.wikipedia.org/wiki/MacOS">MacOS</a>, or <a href="https://en.wikipedia.org/wiki/Linux">Linux</a> with no extra code (<a href="https://en.wikipedia.org/wiki/Nerd">I tried</a> all three).</li>
<li>Encourage further <a href="https://en.wikipedia.org/wiki/Scalability">extension</a> with lots of Rust-y goodness.</li>
</ol>
<p><a href="https://en.wikipedia.org/wiki/C-sharp_minor">C# minor</a> has a funky, dark kind of vibe - <a href="https://en.wikipedia.org/wiki/Lullaby_(The_Cure_song)">Lullaby</a> by <a href="https://en.wikipedia.org/wiki/The_Cure">The Cure</a>, <a href="https://en.wikipedia.org/wiki/Message_in_a_Bottle_(song)">Message in a Bottle</a> by <a href="https://en.wikipedia.org/wiki/The_Police">The Police</a>, <a href="https://en.wikipedia.org/wiki/Feel_It_Still">Feel It Still</a> by <a href="https://en.wikipedia.org/wiki/Portugal._The_Man">Portugal, The Man</a>,  a bunch of <a href="https://en.wikipedia.org/wiki/C-sharp_minor#Notable_songs">others</a>.  Your computer could be the next <a href="https://en.wikipedia.org/wiki/Dolly_Parton">Dolly Parton</a> (<a href="https://en.wikipedia.org/wiki/Jolene_(song)">Jolene</a>):</p>
<pre><code class="language-txt">$ ./music -b C#2 -o 4 -s minor
.: Cool Tunes :.
Generating music from the C# minor scale
Octaves: 2 - 6
[ C# D# E F# G# A B C# ]
</code></pre>
<p>However, at the end of the day, it's just the thing in the cover image.</p>
<p>While the complete runnable source code is embedded within this post, the full project can also be found on <a href="https://github.com/deciduously/music">GitHub</a> along with some <a href="https://github.com/deciduously/music/releases/tag/v0.1.0">pre-compiled binaries</a>.  Feel free to make a PR!</p>
<h2>Table of Contents</h2>
<ul>
<li><a href="#preamble">Preamble</a></li>
<li><a href="#the-meme">The Meme</a></li>
<li><a href="#the-program">The Program</a>
<ul>
<li><a href="#project-structure">Project Structure</a>
- <a href="#dependencies">Dependencies</a>
- <a href="#test-driven-development">Test-Driven Development</a>
- <a href="#entry-point">Entry Point</a>
- <a href="#traits">Traits</a></li>
<li><a href="#random-numbers">Random Numbers</a></li>
<li><a href="#mapping-numbers-to-notes">Mapping Numbers To Notes</a>
- <a href="#a-little-physics">A Little Physics</a>
- <a href="#sine-waves">Sine Waves</a>
- <a href="#pitch">Pitch</a>
- <a href="#singing">Singing</a>
- <a href="#a-little-music-theory">A Little Music Theory</a>
- <a href="#scientific-pitch-notation">Scientific Pitch Notation</a>
- <a href="#intervals">Intervals</a>
- <a href="#scales">Scales</a>
- <a href="#key">Key</a>
- <a href="#circle-of-fifths">Circle of Fifths</a>
- <a href="#diatonic-modes">Diatonic Modes</a>
- <a href="#non-heptatonic-scales">Non Heptatonic Scales</a>
<ul>
<li><a href="#generating-music">Generating Music</a>
<ul>
<li><a href="#cents">Cents</a></li>
<li><a href="#random-notes">Random Notes</a></li>
<li><a href="#user-parameters">User Parameters</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#challenges">Challenges</a></li>
</ul>
<h2>Preamble</h2>
<p><em><a href="#table-of-contents">top</a></em></p>
<p>This tutorial is aimed at <a href="https://en.wikipedia.org/wiki/Novice">beginners</a> (and up) who are comfortable solving problems with at least one <a href="https://en.wikipedia.org/wiki/Imperative_programming">imperative</a>, <a href="https://en.wikipedia.org/wiki/Object-oriented_programming">object-oriented</a> <a href="https://en.wikipedia.org/wiki/Programming_language">language</a>.  It does not matter if that's <a href="https://en.wikipedia.org/wiki/JavaScript">JavaScript</a> or <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> or <a href="https://en.wikipedia.org/wiki/Object_Pascal">Object Pascal</a>, I just assume you know the <a href="https://en.wikipedia.org/wiki/Syntax_(programming_languages)">basic</a> <a href="https://en.wikipedia.org/wiki/Semantics_(computer_science)">building</a> <a href="https://en.wikipedia.org/wiki/Standard_library">blocks</a> of <a href="https://en.wikipedia.org/wiki/Computer_programming">creating a program</a> in an object-oriented style.  If you already know Rust some of this will be skimmable, but this is primarily a post about the problem space and not &quot;how to use Rust&quot;.</p>
<p>You do not need any prior knowledge of physics or music theory, but there will be a tiny smattering of <a href="https://en.wikipedia.org/wiki/Elementary_algebra">elementary algebra</a>.  I promise it's quick.</p>
<p>I have two disclaimers before getting started:</p>
<ol>
<li><a href="https://en.wikipedia.org/wiki/Existence">There are</a> <a href="https://en.wikipedia.org/wiki/257_(number)">257</a> <a href="https://en.wikipedia.org/wiki/Hyperlink">links</a> <a href="https://en.wikipedia.org/wiki/Boston">here</a>, <a href="https://en.wikipedia.org/wiki/199_(number)">199</a> <a href="https://en.wikipedia.org/wiki/Element_(mathematics)">of them</a> <a href="https://en.wikipedia.org/wiki/Codomain">to</a> <a href="https://en.wikipedia.org/wiki/Main_Page">Wikipedia</a>.  <a href="https://en.wikipedia.org/wiki/Conditional_(computer_programming)">If</a> <a href="https://en.wikipedia.org/wiki/You">you're</a> <a href="https://en.wikipedia.org/wiki/Autodidacticism">that</a> <a href="https://en.wikipedia.org/wiki/Impulsivity">kind</a> <a href="https://en.wikipedia.org/wiki/Preposition_and_postposition">of</a> <a href="https://en.wikipedia.org/wiki/Person">person</a>, <a href="https://en.wikipedia.org/wiki/Innovation">set</a> <a href="https://en.wikipedia.org/wiki/Law">rules</a>.</li>
<li>Further to Point 1, most of this I learned myself on Wikipedia, some of it while writing this post.  The rest is what I remember from <a href="https://en.wikipedia.org/wiki/High_school_(North_America)">high school</a> as a <a href="https://en.wikipedia.org/wiki/Euphonium">band geek</a>, which was over <a href="https://en.wikipedia.org/wiki/Decade">ten years</a> <a href="https://en.wikipedia.org/wiki/Past">ago</a>.  I do believe it's generally on the mark, but I am making no claims of authority.  If you see something, <a href="https://en.wikipedia.org/wiki/Allen_Kay#Advertisements">say something</a>.</li>
</ol>
<h2>The Meme</h2>
<p><em><a href="#table-of-contents">top</a></em></p>
<p>This post was inspired by this <a href="https://en.wikipedia.org/wiki/Internet_meme">meme</a> I saw when I was <em>attempting</em> to casually browse <a href="https://en.wikipedia.org/wiki/Reddit">Reddit</a>:</p>
<p><img src="https://i.redd.it/uirqnamnjpz31.jpg" alt="the meme" /></p>
<p>I couldn't let myself just scroll past that one, <a href="https://en.wikipedia.org/wiki/Diatribe">clearly</a>.  Here's a version of the <a href="https://en.wikipedia.org/wiki/Bash_(Unix_shell)"><code>bash</code></a> <a href="https://en.wikipedia.org/wiki/Pipeline_(Unix)">pipeline</a> at the bottom with slightly different hard-coded values, taken from <a href="https://blog.robertelder.org/bash-one-liner-compose-music/">this blog post</a> by <a href="https://www.robertelder.org/">Robert Elder</a> that explores it:</p>
<pre><code class="language-bash">cat /dev/urandom | hexdump -v -e '/1 &quot;%u\n&quot;' | awk '{ split(&quot;0,2,4,5,7,9,11,12&quot;,a,&quot;,&quot;); for (i = 0; i &lt; 1; i+= 0.0001) printf(&quot;%08X\n&quot;, 100*sin(1382*exp((a[$1 % 8]/12)*log(2))*i)) }' | xxd -r -p | aplay -c 2 -f S32_LE -r 16000
</code></pre>
<p>The linked blog post is considerably more brief and assumes a greater degree of background knowledge than this one, but that's not to discredit it at as a fantastic source.  That write-up and Wikipedia were all I needed to complete this translation, and I had absolutely not a clue how this whole thing worked going in.</p>
<p>I've gotta be honest - I didn't even try the <code>bash</code> and immediately dove into the pure Rust solution.  Nevertheless, it serves as a <a href="https://en.wikipedia.org/wiki/Solid">solid</a> <a href="https://en.wikipedia.org/wiki/Flight_level">30,000ft</a> <a href="https://en.wikipedia.org/wiki/Plan">roadmap</a>:</p>
<ol>
<li><code>cat /dev/urandom</code>: Get a stream of random binary data.</li>
<li><code>hexdump -v -e '/1 &quot;%u\n&quot;'</code>: Convert binary to 8-bit base-10 integers (0-255).</li>
<li><code>awk '{ split(&quot;0,2,4,5,7,9,11,12&quot;,a,&quot;,&quot;); for (i = 0; i &lt; 1; i+= 0.0001) printf(&quot;%08X\n&quot;, 100*sin(1382*exp((a[$1 % 8]/12)*log(2))*i)) }'</code>: Map integers to pitches and return sound wave samples.</li>
<li><code>xxd -r -p</code>: Convert hexadecimal samples back to binary.</li>
<li><code>aplay -c 2 -f S32_LE -r 16000</code>: Play back binary samples as sound wave.</li>
</ol>
<p>Don't worry at all if some or all of this is incomprehensible.  You don't need to have a clue how any of it works yet.  This program is not a direct translation of that <a href="https://en.wikipedia.org/wiki/Source_code">code</a>, and I'm not going to elaborate much on what any of the specific commands in the pipeline mean (read the linked post for that), just the relevant logic.   By the time we're done, you'll be able to pick apart the whole thing yourself.</p>
<p>If you'd like the challenge of implementing this yourself from scratch in your own language, <strong>stop right here</strong>.  If you get stuck, this should all apply to whatever you've got going unless you've gone real funky with it - in which case, it sounds cool and you should show me.</p>
<p><a href="https://en.wikipedia.org/wiki/Party">¡Vámonos!</a></p>
<h2>The Program</h2>
<p><em><a href="#table-of-contents">top</a></em></p>
<h3>Project Structure</h3>
<p><em><a href="#table-of-contents">top</a></em></p>
<p>Before getting started, ensure you have at least the default stable Rust toolchain <a href="https://www.rust-lang.org/tools/install">installed</a>.  If you've previously installed <code>rustup</code> at any point, just issue <code>rustup update</code> to grab the latest stable build.  This code was written with <code>rustc</code> <a href="https://blog.rust-lang.org/2019/11/07/Rust-1.39.0.html">version 1.39.0</a> (released <a href="https://en.wikipedia.org/wiki/November_4">November 4</a>, <a href="https://en.wikipedia.org/wiki/2019">2019</a>), but should compile on any version compatible with <a href="https://doc.rust-lang.org/edition-guide/rust-2018/index.html">Rust 2018</a>.</p>
<p>Then, spin up a new library project:</p>
<pre><code class="language-txt">$ cargo new music --lib
</code></pre>
<p>Open your new <code>music</code> project directory in the environment of your choice.  If you're not already sure what to use with Rust, I recommend <a href="https://code.visualstudio.com/">Visual Studio Code</a> with the <a href="https://github.com/rust-lang/rls">Rust Language Server</a> installed for in-editor development support.  If you have <code>rustup</code> present, the <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust">VS Code RLS extension</a> has a one-click set up that's worked for me without a hitch on both Linux and Windows 10.</p>
<h4>Dependencies</h4>
<p><em><a href="#table-of-contents">top</a></em></p>
<p>We'll use a few crates, which is the Rust term for external libraries.  Two of them give us functionality not found in the Rust standard library:</p>
<ul>
<li><a href="https://docs.rs/rand/0.7.2/rand/"><code>rand</code></a> - <a href="https://en.wikipedia.org/wiki/Random_number_generation">Random number generation</a></li>
<li><a href="https://docs.rs/rodio/0.10.0/rodio/"><code>rodio</code></a> - <a href="https://en.wikipedia.org/wiki/Audio_signal">Audio signal playback</a></li>
</ul>
<p><code>rand</code> is in place of <a href="https://en.wikipedia.org/wiki//dev/random"><code>/dev/urandom</code></a>, and <code>rodio</code> will cover  and <a href="https://linux.die.net/man/1/aplay"><code>aplay</code></a>.  We can replace <a href="https://en.wikipedia.org/wiki/Hex_dump"><code>hexdump</code></a>, <a href="https://www.systutorials.com/docs/linux/man/1-xxd/"><code>xxd</code></a>, and the <code>awk</code> logic built-in stuff.  The <code>rand</code> crate provides several different random number generators (RNGs), and the one perfect for this application isn't included by default.  We have to specifically add it to the configuration, so its declaration is split out to deifne multiple keys.</p>
<p>The other two are just for programmer comfort.  I also use <a href="https://docs.rs/pretty_assertions/0.6.1/pretty_assertions/"><code>pretty_assertions</code></a> to make the <a href="https://en.wikipedia.org/wiki/Unit_testing">test runner</a> output a little prettier and <a href="https://github.com/TeXitoi/structopt"><code>structopt</code></a> to get a minimal-effort CLI.</p>
<p>In <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]

rodio = &quot;0.10&quot;
structopt = &quot;0.3&quot;

# the section below is equivalent TOML to:
# rand = { features = [ &quot;small_rng&quot; ], version = &quot;0.7&quot; }
# it's a style preference
[dependencies.rand]

features = [ &quot;small_rng&quot; ]
version = &quot;0.7&quot;

[dev-dependencies]

pretty_assertions = &quot;0.6&quot;
</code></pre>
<h4>Test Driven Development</h4>
<p><em><a href="#table-of-contents">top</a></em></p>
<p>Cargo has auto-created a file at <code>src/lib.rs</code> to define your library, but hold on - we're going to write this program using <a href="https://en.wikipedia.org/wiki/Test-driven_development">Test-Driven Development</a>, or TDD.  This means we're going to define the expected behavior of new functionality <em>before</em> attempting the implementation.  Here's an example of a test we'll write later:</p>
<pre><code class="language-rust">#[test]
fn test_add_interval() {
    use Interval::*;
    assert_eq!(Unison + Unison, Unison);
    assert_eq!(Unison + Maj3, Maj3);
    assert_eq!(Maj2 + Min3, Perfect4);
    assert_eq!(Octave + Octave, Unison);
    assert_eq!(Tritone + Tritone, Unison);
    assert_eq!(Maj7 + Min3, Maj2);
}
</code></pre>
<p>Each test is just a plain Rust function.  In it we use a feature of our library and assert that the result matches the expected result that we hardcode.  In this test, we're specifying the expected behavior when adding musical intervals together with the <code>+</code> operator.  This way, we can tell immediately if the code we write actually matches the specification.  As our code evolves we'll immediately notice if we break functionality that worked previously.</p>
<p>The Rust toolchain has a test runner built-in, so this all works out of the box.  Every function marked <code>#[test]</code> will be executed during an invocation of <code>cargo test</code>, so we can see anywhere our expectations are not met in the whole program.</p>
<p>All of our tests will live in their own separate module.  Create a new file at <code>src/test.rs</code>:</p>
<pre><code class="language-rust">use super::*;
use pretty_assertions::assert_eq;

#[test]
fn test_cool_greeting() {
    assert_eq!(GREETING, &quot;.: Cool Tunes :.&quot;);
}
</code></pre>
<p>If the two arguments to <code>assert_eq!()</code> are not equal, this test will fail and you'll get pretty-printed output showing you the difference between the two.  I generally put the test code in the first argument and the hardcoded expected value in the second.</p>
<p>This test is importing a constant, <code>GREETING</code>, from our library, and expecting it to be the string <code>Cool Tunes (tm)</code>.  This code will fail to compile, though - there's no such <code>super::GREETING</code> constant available to test!  The <code>super</code> part means &quot;one module higher&quot; - <code>test</code> is a child module of the <code>music</code> library we're writing, so the crate root in <code>lib.rs</code> corresponds to <code>super</code> here.  You could also say <code>crate::*</code> or <code>music::*</code>.  Now open up <code>src/lib.rs</code> and replace the contents with this:</p>
<pre><code class="language-rust">#[cfg(test)]
mod test;

pub const GREETING: &amp;str = &quot;.: Cool Tunes :.\n&quot;;
</code></pre>
<p>The <code>#[cfg(test)]</code> tag tells the compiler to only build the <code>test</code> module when we're using the test runner.  The compiler won't even look at it when using <code>cargo run</code>.</p>
<p>Now we can give <code>cargo test</code> a go - the first build will take the longest as it gathers and builds dependencies for the first time:</p>
<p><img src="https://thepracticaldev.s3.amazonaws.com/i/4wgtozis0bfoxnmedvrp.png" alt="test fail" /></p>
<p>Whoops - no need to include a newline with the greeting string, we'll pass it to <a href="https://doc.rust-lang.org/std/macro.println.html"><code>println!()</code></a> in the program which includes one:</p>
<pre><code class="language-diff">  #[cfg(test)]
  mod test;

- pub const GREETING: &amp;str = &quot;.: Cool Tunes :.\n&quot;;
+ pub const GREETING: &amp;str = &quot;.: Cool Tunes :.&quot;;
</code></pre>
<p>Let's try this again:</p>
<p><img src="https://thepracticaldev.s3.amazonaws.com/i/ajubi9o41dsfvkfwcnqa.png" alt="test pass" /></p>
<p>Good to go!  Throughout this post new sections of code will be preceded by a test with he <code>#[test]</code> tag that defines the behavior we're aiming for.  These tests should all go in <code>src/test.rs</code>.</p>
<h4>Entry Point</h4>
<p><em><a href="#table-of-contents">top</a></em></p>
<p>Finally, create a directory called <code>src/bin</code>.  This optional module is where Cargo will by default expect an executable, if present.  Place a file at <code>src/bin/music.rs</code> - this filename will be the name of the executable, so when distributed you'd execute <code>./music</code> to run the code in <code>main()</code>:</p>
<pre><code class="language-rust">use music::*;

fn main() {
    println!(&quot;{}&quot;, GREETING);
}
</code></pre>
<p>Give it a go with <code>cargo run</code>:</p>
<pre><code class="language-txt">$ cargo run
   Compiling music-rebuild v0.1.0 (/home/you/code/music)
    Finished dev [unoptimized + debuginfo] target(s) in 0.16s
     Running `target/debug/music`
.: Cool Tunes :.
</code></pre>
<p>The <em>coolest</em> tunes.  You can see right above the output the actual name of the executable file being run - you can find it right in your project's <code>target</code> directory:</p>
<p><img src="https://thepracticaldev.s3.amazonaws.com/i/15gwbnp3j15lb2a8fhps.png" alt="executable screenshot" /></p>
<p>Your <code>music/src</code> directory should look like the following:</p>
<pre><code class="language-txt">~/code/music $ tree src
src
├── bin
│   └── music.rs
├── lib.rs
└── test.rs

1 directory, 3 files
</code></pre>
<p>This is a good time for an initial commit:</p>
<pre><code class="language-txt">$ git add .
$ git commit -m &quot;Initial Commit&quot;
</code></pre>
<p>You can run a faster compilation pass with <code>cargo check</code> if you just want the compiler to verify your code's integrity, not produce a binary.</p>
<h4>Traits</h4>
<p>If you're already familiar with developing in Rust, you can probably skip right to <a href="#random-numbers">Random Numbers</a>.</p>
<p>If you are brand new to the language, you should expect to spend a little longer with the code in this post to extract the relevant bits.  I'm not going to devote much time in general to Rust-specific topics, as there is a vast amount of great material already available devoted to that, but out of all of Rust's interesting properties this is the big one you'll need to know about to follow along with this program.</p>
<p>Most of this code is compartmentalized using <a href="https://doc.rust-lang.org/book/ch10-02-traits.html">Rust traits</a>, which collect bits of composable functionality (my type &quot;has-a&quot; <code>ScreenWidget</code> trait that implements those methods).  It's OOP, Jim, <a href="https://en.wikipedia.org/wiki/Star_Trekkin%27">but not as we know it</a>.  In this post, you can think of them like interfaces in more traditional <a href="https://en.wikipedia.org/wiki/Class-based_programming">class-based OOP</a> languages.  They're a little more powerful, but that analogy does fit and is enough to get you up and running.</p>
<p>One big difference from &quot;regular&quot; object-oriented programming is that this is all we get.  There's no such thing as inheritance (my type &quot;is-a&quot; more specific <code>ScreenWidget</code> type and inherits or overrides those methods).  As a result, composition of functionality features heavily in Rust code in the form of <code>impl SomeTrait for MyType {}</code> blocks, with collections of method definitions inside.</p>
<p>The compiler can infer types in many situations, and can auto-fill these trait implementations for us in many cases with a <code>#[derive(..)]</code> tag.  In this case, the default <code>value</code> is also the <code>Default</code> value for the primitive type <code>i32</code>, which for all the numeric types is <code>0</code> (or <code>0.0</code>).  When that's what we want in this context too, we can ask the compiler to auto-generate the above code with this syntax:</p>
<pre><code class="language-rust">#[derive(Default)]
struct MyType {
    value: i32,
}
</code></pre>
<p>Writing this code is nearly equivalent to the former in terms of the output machine code.  This syntax is a <a href="https://en.wikipedia.org/wiki/Macro_(computer_science)">macro</a> that will expand to the full Rust code for any <code>impl Trait</code> block being derived blocks before your program is compiled as if it had been fully written out.  In general, a struct can derive a trait as long as all of its members implement that trait, either derived or hand-implemented, because the compiler will just call that method for whatever type it needs.  The auto-derived <code>Default</code> implementation looks like this when your code reaches the compiler:</p>
<pre><code class="language-rust">impl Default for MyType {
    fn default() -&gt; Self {
        Self { value: i32::default() }
    }
}
</code></pre>
<p>Now we can use <code>MyType::default()</code> to construct an object of this type - the following two statements store the same object to <code>obj</code>:</p>
<pre><code class="language-rust">let obj = MyType::default();
// or
let obj: MyType = MyType { value: 0 }
</code></pre>
<p>It's up to the specific type to decide what happens, as long as the input and output types match.  Whenever you get lost just remember - it's <a href="https://en.wikipedia.org/wiki/Turtles_all_the_way_down">traits all the way down</a>.</p>
<p>We can also define methods that aren't associated with any trait with, e.g.:</p>
<pre><code class="language-rust">impl MyType {
    fn some_specific_thing(&amp;self) {
        // ..
    }
}
</code></pre>
<h3>Random Numbers</h3>
<p><em><a href="#table-of-contents">top</a></em></p>
<p>The first part of the one-liner is  <code>cat /dev/urandom | hexdump -v -e '/1 &quot;%u\n&quot;'</code>, which gets a source of random bytes (8-bit binary values) and shows them to the user formatted as base-10 integers.</p>
<p>When I sat down to write this program, I decided to knock out this functionality first mostly because I immediately knew how.  The <code>rand</code> crate can give us random 8-bit integers out of the box by using the so-called <a href="https://docs.serde.rs/syn/struct.Turbofish.html">&quot;turbofish&quot;</a> syntax to specify a type: <code>random::&lt;u8&gt;()</code> will produce a random <a href="https://en.wikipedia.org/wiki/Signedness">unsigned</a> <a href="https://en.wikipedia.org/wiki/8-bit">8 bit</a> integer (<a href="https://doc.rust-lang.org/nightly/std/primitive.u8.html"><code>u8</code></a>) with the default generator settings.</p>
<p>To match the one-liner exactly, we could write an <a href="https://doc.rust-lang.org/std/iter/index.html"><code>Iterator</code></a> implementation with a <code>next()</code> method like this - no need to copy this code to your project, we don't use it again:</p>
<pre><code class="language-rust">impl Iterator for RandomBytes {
    type Item = u8;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        Some(random::&lt;Self::Item&gt;())
    }
}
</code></pre>
<p>If we endlessly call this method, we'll get output that matches <code>cat /dev/urandom | hexdump -v -e '/1 &quot;%u\n&quot;'</code> exactly:</p>
<pre><code class="language-rust">fn main() {
    let mut rands = RandomBytes::new();
    loop {
        println!(&quot;{}&quot;, rands.next().unwrap());
    }
}
</code></pre>
<p>I'm not bothering to show you the full runnable snippet - try to build the <code>RandomBytes</code> struct yourself if you'd like.  In a <code>bash</code> one-liner you've got to take your randomness where you can get it, but the <code>rand</code> crate provides a richer set of tools.  Before streaming in something random, we need to think about what exactly it is we're randomizing.</p>
<p>In this application, we want to pick a musical note from a set of valid choices at random.  The <code>awk</code> code does this with the modulo operator:  <code>list[n % listLength]</code>.  That will take a random index that's ensured to be a valid list member.  See if you can spot the corresponding section of the cover image code.</p>
<p>We get to use the <a href="https://docs.rs/rand/0.7.2/rand/seq/trait.SliceRandom.html"><code>rand::seq::SliceRandom</code></a> trait here.  This gives us a <code>choose()</code> method that we can call on any <a href="https://doc.rust-lang.org/std/slice/index.html">slice</a> to pull a random member.</p>
<p>So, there's no need for a <code>RandomBytes</code> iterator.  Instead, we need to define a list of notes and call <code>[notes].choose(&amp;mut RNG)</code> on it to get a specific note to play.</p>
<h3>Mapping Numbers To Notes</h3>
<p><em><a href="#table-of-contents">top</a></em></p>
<p>Take a closer look at step 3 of the pipeline.  This code closely resembles the core logic we ultimately end up with:</p>
<pre><code class="language-bash">split(&quot;0,2,4,5,7,9,11,12&quot;,a,&quot;,&quot;);
for (i = 0; i &lt; 1; i += 0.0001)
    printf(&quot;%08X\n&quot;,
           100 * sin(1382 * exp((a[$1 % 8] / 12) * log(2)) * i))
</code></pre>
<p>This is probably still not too helpful for most - there's <a href="https://en.wikipedia.org/wiki/Magic_number_(programming)">magic numbers</a> and <a href="https://en.wikipedia.org/wiki/Sine">sines</a> and <a href="https://en.wikipedia.org/wiki/Logarithm">logarithms</a> (oh, my) - and its written in freakin' <a href="https://en.wikipedia.org/wiki/AWK"><code>AWK</code></a>.  Don't despair if this still doesn't mean much (or literally anything) to you.</p>
<p>We can glean a bit of information at a glance, though, and depending on your current comfort with this domain you may be able to kind of understand the general idea here.  It looks like we're going to tick up floating point values by ten-thousandths from zero to one (<code>0.0</code>, <code>0.0001</code>, <code>0.0002</code>, etc.) with <code>for (i = 0; i &lt; 1; i += 0.0001)</code>, and do... I don't know, some math on each value.  In that math we're using both <code>i</code>, the current fractional part from 0 to 1, and <code>$1</code>, which is the random 8-bit integer being piped in.  Specifically, we're indexing into a list <code>a</code>:  <code>a[$1 % 8]</code>.  In other words, we're using the random byte <code>0-255</code> to select an index <code>0-7</code> from this list.</p>
<p>The list is defined with <code>split(&quot;0,2,4,5,7,9,11,12&quot;,a,&quot;,&quot;);</code>, which means split the first parameter string input by the third parameter  <code>&quot;,&quot;</code>, and store the resulting list of elements to the second parameter <code>a</code> (<code>awk</code> is terse).  After we do the math, we're going to print it out as an 8-digit hex number: <code>printf(&quot;%08X\n&quot;, someResult)</code> - this <a href="https://en.wikipedia.org/wiki/Printf_format_string"><code>printf</code></a> formatter means we want a <a href="https://en.wikipedia.org/wiki/Npm_(software)#Notable_breakages">0-padded</a> number that's 8 digits long in <a href="https://en.wikipedia.org/wiki/Letter_case">upper-case</a> <a href="https://en.wikipedia.org/wiki/Hexadecimal">hexadecimal</a>.  The <a href="https://en.wikipedia.org/wiki/Decimal">base 10</a> integer <a href="https://en.wikipedia.org/wiki/Phrases_from_The_Hitchhiker%27s_Guide_to_the_Galaxy#Answer_to_the_Ultimate_Question_of_Life,_the_Universe,_and_Everything_(42)"><code>42</code></a> would be printed as <code>0000002A</code>.</p>
<p>TL;DR for each ten-thousandth between 0 and 1 <code>i</code>, select a value <code>n</code> from <code>[0,2,4,5,7,9,11,12]</code> and return the result of <code>100 * sin(1382 * exp((n / 12) * log(2) * i)</code>.</p>
<p>If you recognize this formula, awesome!  You can probably skim the next section.  If not, it's still <a href="https://en.wikipedia.org/wiki/Phrases_from_The_Hitchhiker%27s_Guide_to_the_Galaxy#Don&#x27;t_Panic">not time to panic</a>.  We just need to get some fundamentals out of the way.</p>
<h4>A Little Physics</h4>
<p><em><a href="#table-of-contents">top</a></em></p>
<p><a href="https://en.wikipedia.org/wiki/Sound">Sound</a> is composed physically of <a href="https://en.wikipedia.org/wiki/Vibration">vibrations</a>.  These vibrations cause perturbations in some <a href="https://en.wikipedia.org/wiki/Transmission_medium">medium</a>, which radiate out from the source of the vibration, and those perturbations cause <a href="https://en.wikipedia.org/wiki/Sound_pressure">tiny oscillating variations</a> in local atmospheric pressure.  These variations are what we experience as sound.  When we're talking about <a href="https://en.wikipedia.org/wiki/Hearing">hearing</a> a sound with our <a href="https://en.wikipedia.org/wiki/Ear">ears</a>, the medium is usually <a href="https://en.wikipedia.org/wiki/Atmosphere_of_Earth">air</a>.</p>
<h5>Sine Waves</h5>
<p><em><a href="#table-of-contents">top</a></em></p>
<p>Sound propagates as a <a href="https://en.wikipedia.org/wiki/Wave">wave</a>.  In <a href="https://en.wikipedia.org/wiki/Reality">reality</a> a sound contains many components but for this program we can talk about a super-simplified version that can be represented as a single <a href="https://en.wikipedia.org/wiki/Sine_wave">sine wave</a>:</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/6/6d/Sine_waves_different_frequencies.svg" alt="sine waves" /></p>
<p>If the x-axis is time, a sine wave represents a recurring action with a smooth (or analog) oscillation between peaks.  Lots of physical phenomena are analog in nature - picture a ball getting tossed, rising and then falling.  The ball passes through every point in between the highest point it hits and the ground, so we can measure at any arbitrary instant an exact fractional height.  It doesn't fall from 8 meters to 7 meters all at once, it passes through 7.9, 7.8, 7.7, and all infinitesimally small heights in between too.  It's the same with sound.</p>
<p>Instead of height above the ground on the y axis, we have a <a href="https://en.wikipedia.org/wiki/Sound_pressure">pressure gradient</a> from an equilibrium.  The air is getting rapidly pushed and pulled by this vibration across space as a wave.  It's still a physical phenomenon - a pressure gradient rises to a peak and then falls back to equilibrium and then below to an opposite peak, oscillating back and forth.  It doesn't just magically become a different higher value all at once.  A guitar string wobbling passes through each point in space between the two extremes it's tensing to and from, so the vibrations it causes oscillate in kind.</p>
<p>You can actually use <a href="https://en.wikipedia.org/wiki/Fourier_transform">math</a> to represent multi-component sound waves as a single wave - the ability to do so is what enables the whole field of <a href="https://en.wikipedia.org/wiki/Telecommunication">telecommunications</a>.  We're not going to touch that today, partially because I don't actually know how to perform a Fourier transform myself (yet).  One single sine wave is enough of a signal to produce a tone, so we can keep it simple.</p>
<p>There are two interesting properties of a sine wave: the <a href="https://en.wikipedia.org/wiki/Amplitude">amplitude</a>, which measures the current deviation from the 0 axis for a given <em>x</em>, and the <a href="https://en.wikipedia.org/wiki/Frequency">frequency</a>, which is how close together these peaks at maximal amplitudes are, or how frequently this recurring thing happens.  The combination of the two dictate how we perceive the sound.  The amplitude will be perceived as <a href="https://en.wikipedia.org/wiki/Loudness">volume</a> and the frequency as <a href="https://en.wikipedia.org/wiki/Pitch_(music)">pitch</a>.</p>
<p>You can do cool things like frequency modulation and amplitude modulation to encode your signal as modulations of one of these properties:</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/a/a4/Amfm3-en-de.gif" alt="modulation" /></p>
<p>This is how FM and AM radio process incoming sound signals to broadcast them to your radio, which can then perform the reverse and play back the original sound.   We also don't do any of that today, but you could experiment with these functions with this as a base.</p>
<h5>Pitch</h5>
<p><em><a href="#table-of-contents">top</a></em></p>
<p>The standard unit for frequency is the <a href="https://en.wikipedia.org/wiki/Hertz">Hertz</a>, abbreviated <code>Hz</code>, which measures the <em>number of cycles per second</em>.  One cycle here is the distance (or time) between two peaks on the graph, or the time it takes to go all the way around the circle once:</p>
<p><img src="https://media.giphy.com/media/F5rQlfTXqCJ8c/giphy.gif" alt="cycle gif" /></p>
<p>According to my super scientific smartphone stopwatch observations, this gif is chugging along at a whopping 0.2Hz.</p>
<p>Recall above that we saw we're going to run a loop like this:  <code>for (i = 0; i &lt; 1; i += 0.0001)</code>.  In that loop, the math we process includes the function <code>sin()</code>.  If one were to, say, calculate a bunch of points along a single cycle of a sine wave like this one, it sure seems like just such a loop could get the job done.</p>
<p>The higher the frequency, or closer together the peaks representing maximum positive amplitudes, the higher the pitch.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/e/ea/Wave_frequency.gif" alt="frequency" /></p>
<p>Sound is a continuous spectrum of frequency, but when we make music we tend to prefer <a href="https://en.wikipedia.org/wiki/Musical_note">notes</a> at set frequencies, or pitches.  I'm using <a href="https://en.wikipedia.org/wiki/Fundamental_frequency">fundamental frequency</a> and pitch interchangeably, because for this application specifically they are, but go Wiki-diving if you want to learn about the distinction and nuance at play here.  The nature of sound is super cool but super complex and outside of the scope of this post - we just want to hear some numbers sing, we don't need to hear a full orchestra.</p>
<p>One of the super cool things about it is the <a href="https://en.wikipedia.org/wiki/Octave">octave</a>.  Octaves just sound related, you know?</p>
<p>It turns out the relationship is physical - to increase any pitch by an octave, you double the frequency.  Not only that, this fixed ratio actually holds for any arbitrary smaller or larger interval as well.  This system is called <a href="https://en.wikipedia.org/wiki/Equal_temperament">&quot;equal temperament&quot;</a> - every pair of adjacent notes has the same ratio, regardless of how you define &quot;adjacent&quot;.  To get halfway to the next octave, you multiply by 1.5 instead of 2.</p>
<p>To start working with concrete numbers, we need some sort of standard to start multiplying from.   Some of the world has settled on <a href="https://en.wikipedia.org/wiki/A440_(pitch_standard)">440Hz</a> - it's <a href="https://en.wikipedia.org/wiki/International_Organization_for_Standardization">ISO</a> <a href="https://www.iso.org/standard/3601.html">16</a>, at least.  It's also apparently called &quot;The Stuttgart Pitch&quot;, which is funny.</p>
<p><img src="https://i.imgflip.com/3h0y3g.jpg" alt="stuttgart" /></p>
<p>We can keep track of Hertz with a double-precision floating-point value:</p>
<pre><code class="language-rust">#[derive(Debug, Default, Clone, Copy, PartialEq, PartialOrd)]
pub struct Hertz(f64);
</code></pre>
<p>This is just a floating point value, but I didn't just assign an alias like <code>type Hertz = f64</code>.   Instead, I made my very own fully-fledged new type.  A lot of this program will involve type conversions and unit conversions, but they will all be explicit and defined in places we expect.  When manipulating our increasing set of abstractions we don't want to have to think about things like floating point accuracy - it should just work as we expect.  The <a href="https://doc.rust-lang.org/1.37.0/book/ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types">tuple struct</a> syntax is perfect for this, when the underlying value is just a single value but there may be complex relationships with other types.</p>
<p>Luckily, the compiler can actually derive a number of things for us straight from the inner value.  For the rest, we'll provide our own implementations that destructure the tuple:</p>
<pre><code class="language-rust">#[test]
fn test_subtract_hertz() {
    assert_eq!(Hertz(440.0) - Hertz(1.0), Hertz(439.0))
}
</code></pre>
<pre><code class="language-rust">use std::ops::Sub;

impl Sub for Hertz {
    type Output = Self;
    fn sub(self, rhs: Self) -&gt; Self::Output {
        Self(self.0 - rhs.0)
    }
}
</code></pre>
<p>This allows us to subtract two <code>Hertz</code> values with the subtraction operator <code>-</code>, and get a <code>Hertz</code> back.  We can also give ourselves some more helpful conversion traits - this gets us both the defined <code>from()</code> and the type-inferred <code>into()</code> in both directions with <code>f64</code>:</p>
<pre><code class="language-rust">impl From&lt;Hertz&gt; for f64 {
    fn from(h: Hertz) -&gt; Self {
        h.0
    }
}

impl From&lt;f64&gt; for Hertz {
    fn from(f: f64) -&gt; Self {
        Self(f)
    }
}
</code></pre>
<p>There are a lot of unit conversions throughout this program but <em>all</em> of them are explicit and defined where we expect them.  This does add to our boilerplate, but reduces the element of surprise - my LEAST favorite element in programming.  Next, we need a way to represent a pitch:</p>
<pre><code class="language-rust">#[derive(Debug, Clone, Copy, PartialEq, PartialOrd)]
pub struct Pitch(Hertz);
</code></pre>
<p>I didn't take <code>Default</code> this time - the default pitch is not 0Hz.  We want our new <code>Pitch</code> type to default to A440, but also accept any arbitrary value:</p>
<pre><code class="language-rust">#[test]
fn test_new_pitch() {
    assert_eq!(Pitch::default(), Pitch(Hertz(440.0)));
    assert_eq!(Pitch::new(MIDDLE_C), Pitch(Hertz(261.626)));
}
</code></pre>
<p>The following code gets us there:</p>
<pre><code class="language-rust">pub const STANDARD_PITCH: Hertz = Hertz(440.0);
pub const MIDDLE_C: Hertz = Hertz(261.626);

// ..

#[derive(Debug, Clone, Copy, PartialEq, PartialOrd)]
pub struct Pitch(Hertz);

impl Pitch {
    pub fn new(frequency: Hertz) -&gt; Self {
        Self(frequency)
    }
}

impl Default for Pitch {
    fn default() -&gt; Self {
        Self(STANDARD_PITCH)
    }
}
</code></pre>
<p>Verify it all with <code>cargo test</code>:</p>
<pre><code class="language-txt">running 3 tests
test test::test_cool_greeting ... ok
test test::test_subtract_hertz ... ok
test test::test_new_pitch ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>I won't keep prompting you to do so, but the prevailing wisdom is to run it after adding every test and watch it fail even before adding the implementation.  Then you can watch it fail in incrementally different ways as you get closer to the correct code.</p>
<h5>Singing</h5>
<p><em><a href="#table-of-contents">top</a></em></p>
<p>Knowing what frequency to use to produce a given pitch is all well and good, but we need to actually make the sound.  When we sing with our <a href="https://en.wikipedia.org/wiki/Human_voice">voice</a>, our <a href="https://en.wikipedia.org/wiki/Speech_organ">speech organs</a> vibrate to produce complex multiple-component sound waves of differing frequencies.  We can program ourselves a little one-frequency &quot;speechbox&quot; that produces a wave programmatically instead of by physically vibrating.</p>
<p>To do so, we're going to perform an <a href="https://en.wikipedia.org/wiki/Analog-to-digital_converter">analog-to-digital conversion</a>.  That's a super fancy term for something that isn't that complicated conceptually.  We're going to <a href="https://en.wikipedia.org/wiki/Graph_of_a_function">graph</a> the function of a single cycle of the target sine wave and <a href="https://en.wikipedia.org/wiki/Sampling_(signal_processing)">sample</a> it.  If you already know how we're doing this part, feel free to skip this explanation.</p>
<p>A sine wave, as we've seen, is smooth.  However, what's a graph but a visualization of a function.  There's some function <code>mySineWave(x)</code> that's this wave when we put in a bunch of fractional numbers between <em>0</em> and <em>1</em>.  The  <code>for (i = 0; i &lt; 1; i += 0.0001)</code> loop is doing exactly that, calculating a series of adjacent points at a fixed interval (<code>0.0001</code>) that satisfy the function of this wave.  That's our analog-to-digital conversion  - we've taken something smooth, a sine wave, and made it digital, or made up of discrete points.  For <code>Pitch::default()</code>, this cycle repeats 440 times each second.</p>
<p>The <a href="https://en.wikipedia.org/wiki/Sampling_(signal_processing)#Sampling_rate">sample rate</a> of an audio stream is how many points to store for each one of these cycles, or is how high-fidelity this &quot;digital snapshot&quot; of the wave is.  Lots of applications use a <a href="https://en.wikipedia.org/wiki/44,100_Hz">44.1KHz</a> sample rate - a bit higher than 10KHz like the example.  According to the <a href="https://en.wikipedia.org/wiki/Nyquist%E2%80%93Shannon_sampling_theorem">sampling theorem</a>, the threshold for ensuring you've captured a sufficient sample from an analog signal is that the sample rate must be greater than twice the frequency you you're sampling.  Humans can hear about 20Hz to 20,000Hz.  This means we need at least 40,000 samples, and 44,100 exceeds that.  The <code>rodio</code> crate defaults to 48KHz, which per that same link is the standard for professional digital audio equipment.</p>
<p>The maximum amplitude this struct can represent is the maximum wave that fits in whatever type is used for the sample, because that's the biggest <em>x</em> will ever be in either direction - <code>1</code> or <code>-1</code>.  This code uses an <code>f32</code>, or single-precision 4-byte float.</p>
<p>The <code>rodio</code> crate actually has a built-in <a href="https://docs.rs/rodio/0.10.0/rodio/source/struct.SineWave.html"><code>rodio::source::SineWave</code></a> that takes a frequency in Hertz but as an unsigned integer.  Go ahead and throw a quick conversion in for our <code>Pitch</code> type:</p>
<pre><code class="language-rust">// lib.rs
use rodio::source::SineWave;

impl From&lt;Pitch&gt; for f64 {
    fn from(p: Pitch) -&gt; Self {
        p.0.into()
    }
}

impl From&lt;Pitch&gt; for SineWave {
    fn from(p: Pitch) -&gt; Self {
        SineWave::new(f64::from(p) as u32)
    }
}
</code></pre>
<p>This code should produce an A440 tone when executed with <code>cargo run</code>:</p>
<pre><code class="language-rust">// bin/music.rs
use rodio::{Sink, source::SineWave, default_output_device};

fn main() {
    let device = default_output_device().unwrap();
    let sink = Sink::new(&amp;device);
    let source =  SineWave::from(Pitch::default());
    sink.append(source);
    sink.sleep_until_end();
}
</code></pre>
<p>I'll briefly cover the other tidbits: <code>default_output_device()</code> attempts to find the running system's currently configured default audio device, and a <a href="https://docs.rs/rodio/0.10.0/rodio/struct.Sink.html"><code>Sink</code></a> is an abstraction for handling multiple sounds.  It works like an audio track.  You can <code>append()</code> a new <code>Source</code> of sound, and the first one appended starts the track.  A newly appended track will play after whatever is playing finishes, but a <code>rodio::source::SineWive</code> is an infinite source.</p>
<p>Finally, we have to <code>sleep_until_end()</code> the thread until the sound completes playing (which for <code>SineWave</code> is never), or else the program will move right along and exit.  You'll have to kill this run with <code>Ctrl-C</code>, this sound will play forever.</p>
<p>By simply modulating the pitch passed to <code>SineWave</code>, we could generate any pitch we want.  That's what the one-liner does, it's selecting an offset to pass from the list <code>[0,2,4,5,7,9,11,12]</code>, so we know that sequence works. And, like, <em>cool</em>, I guess.  We can do a lot better, though.  What's so special about these numbers?</p>
<h4>A Little Music Theory</h4>
<p><em><a href="#table-of-contents">top</a></em></p>
<p>While it's great to have a voice we can sing with with, I'm sure we'd all prefer it if our program learned how to sing on key.  To get oriented, A440 is the A above Middle C on a piano:</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2e/Piano_Frequencies.svg/2560px-Piano_Frequencies.svg.png" alt="piano" /></p>
<h5>Scientific Pitch Notation</h5>
<p><em><a href="#table-of-contents">top</a></em></p>
<p>Instead of frequencies in Hertz, it's much easier to manipulate pitches in terms of <a href="https://en.wikipedia.org/wiki/Scientific_pitch_notation">Scientific Pitch Notation</a>, another fancy name for a simple concept.  The piano keyboard above was labelled according to this standard.  The A440 pitch is denoted <code>&quot;A4&quot;</code> in this system.  We're going to want to parse them from strings:</p>
<pre><code class="language-rust">#[test]
fn test_new_piano_key() {
    use Accidental::*;
    use NoteLetter::*;
    assert_eq!(
        PianoKey::default(),
        PianoKey {
            note: Note {
                letter: C,
                accidental: None
            },
            octave: 0
        }
    );
    assert_eq!(
        PianoKey::new(&quot;A4&quot;).unwrap(),
        PianoKey {
            note: Note {
                letter: A,
                accidental: None
            },
            octave: 4
        }
    );
    assert_eq!(
        PianoKey::new(&quot;G♭2&quot;).unwrap(),
        PianoKey {
            note: Note {
                letter: G,
                accidental: Some(Flat)
            },
            octave: 2
        }
    );
    assert_eq!(
        PianoKey::new(&quot;Gb2&quot;).unwrap(),
        PianoKey {
            note: Note {
                letter: G,
                accidental: Some(Flat)
            },
            octave: 2
        }
    );
    assert_eq!(
        PianoKey::new(&quot;F#8&quot;).unwrap(),
        PianoKey {
            note: Note {
                letter: F,
                accidental: Some(Sharp)
            },
            octave: 8
        }
    );
}
</code></pre>
<p>We also want to reject invalid letters - we can use <code>#[should_panic]</code> to indicate that a panic is the expected behavior.  No need to bother defining a real match:</p>
<pre><code class="language-rust">#[test]
#[should_panic]
fn test_reject_piano_key_too_high() {
    assert_eq!(PianoKey::new(&quot;A9&quot;).unwrap(), PianoKey::default());
}

#[test]
#[should_panic]
fn test_reject_piano_key_invalid_letter() {
    assert_eq!(PianoKey::new(&quot;Q7&quot;).unwrap(), PianoKey::default());
}
</code></pre>
<p>Additionally, we want to go the other way.  We need a <code>to_string()</code> or some such:</p>
<pre><code class="language-rust">#[test]
fn test_piano_key_to_str() {
    assert_eq!(PianoKey::default().to_string(), &quot;C0&quot;.to_string());
    assert_eq!(PianoKey::new(&quot;A#4&quot;).unwrap().to_string(), &quot;A#4&quot;.to_string());
    assert_eq!(PianoKey::new(&quot;Bb5&quot;).unwrap().to_string(), &quot;B♭5&quot;.to_string())
}
</code></pre>
<p>A more robust system would also accept multiple accidentals and coerce, e.g. <code>E#</code> -&gt; <code>F</code>, but this gets us going.</p>
<p>To implement this, it's easiest to start at the bottom.  With <code>NoteLetter</code>, we also want to assign a numeric index but it's not as simple as with the intervals - these don't all have the same value.  We will store an index:</p>
<pre><code class="language-rust">use std::io;
use std::str::FromStr;

#[derive(Debug, Clone, Copy, PartialEq)]
enum NoteLetter {
    C = 0,
    D,
    E,
    F,
    G,
    A,
    B,
}

impl Default for NoteLetter {
    fn default() -&gt; Self {
        NoteLetter::C
    }
}

impl FromStr for NoteLetter {
    type Err = io::Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        match s.to_uppercase().as_str() {
            &quot;A&quot; =&gt; Ok(NoteLetter::A),
            &quot;B&quot; =&gt; Ok(NoteLetter::B),
            &quot;C&quot; =&gt; Ok(NoteLetter::C),
            &quot;D&quot; =&gt; Ok(NoteLetter::D),
            &quot;E&quot; =&gt; Ok(NoteLetter::E),
            &quot;F&quot; =&gt; Ok(NoteLetter::F),
            &quot;G&quot; =&gt; Ok(NoteLetter::G),
            _ =&gt; Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                format!(&quot;{} is not a valid note&quot;, s),
            )),
        }
    }
}
</code></pre>
<p>The notes are C-indexed, for better or for worse, so <code>NoteLetter::default()</code> should return that variant.  We'll talk more about why it's C and not A after learning about Modes below.   Don't worry, it's suitably disappointing.</p>
<p>Next up we have a <code>Note</code> which consists of a letter and optionally an accidental:</p>
<pre><code class="language-rust">#[derive(Default, Debug, Clone, Copy, PartialEq)]
pub struct Note {
    accidental: Option&lt;Accidental&gt;,
    letter: NoteLetter,
}
</code></pre>
<p>For this one, we only want to display a character for an accidental if there's anything there:</p>
<pre><code class="language-rust">impl fmt::Display for Note {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        let acc_str = if let Some(a) = self.accidental {
            format!(&quot;{}&quot;, a)
        } else {
            &quot;&quot;.to_string()
        };
        write!(f, &quot;{:?}{}&quot;, self.letter, acc_str)
    }
}
</code></pre>
<p>There's a little more logic to pull them out of strings:</p>
<pre><code class="language-rust">impl FromStr for Note {
    type Err = io::Error;
    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        let char_strs = char_strs(s);
        let mut char_strs = char_strs.iter();
        // note will be first
        if let Some(letter) = char_strs.next() {
            let letter = NoteLetter::from_str(letter)?;
            if let Some(accidental) = char_strs.next() {
                // check if it's valid
                let accidental = Accidental::from_str(accidental)?;
                return Ok(Self {
                    letter,
                    accidental: Some(accidental),
                });
            } else {
                return Ok(Self {
                    letter,
                    accidental: None,
                });
            }
        }
        Err(io::Error::new(
            io::ErrorKind::InvalidInput,
            format!(&quot;{} is not a valid note&quot;, s),
        ))
    }
}
</code></pre>
<p>This uses one helper function I defined:</p>
<pre><code class="language-rust">#[test]
fn test_char_strs() {
        assert_eq!(char_strs(&quot;Hello&quot;), [&quot;H&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;])
}
</code></pre>
<p>If anyone has a cleaner solution I'm all ears:</p>
<pre><code class="language-rust">fn char_strs&lt;'a&gt;(s: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    s.split(&quot;&quot;)
        .skip(1)
        .take_while(|c| *c != &quot;&quot;)
        .collect::&lt;Vec&lt;&amp;str&gt;&gt;()
}
</code></pre>
<p>The missing piece is the <code>Accidental</code>.  <a href="https://en.wikipedia.org/wiki/Accidental_(music)">Accidentals</a> are represented in strings as <code>♭</code> for flat or <code>#</code> for sharp, which lower or raise the note by one semitone (or <code>Interval::Min2</code>) respectively.  This does produce 14 possible values for 12 possible semitones - the exceptions are wherever there's no black key in between two white keys.</p>
<pre><code class="language-rust">#[derive(Debug, Clone, Copy, PartialEq)]
enum Accidental {
    Flat,
    Sharp,
}

impl fmt::Display for Accidental {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        use Accidental::*;
        let acc_str = match self {
            Flat =&gt; &quot;♭&quot;,
            Sharp =&gt; &quot;#&quot;,
        };
        write!(f, &quot;{}&quot;, acc_str)
    }
}

impl FromStr for Accidental {
    type Err = io::Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        match s {
            &quot;b&quot; | &quot;♭&quot; =&gt; Ok(Accidental::Flat),
            &quot;#&quot; =&gt; Ok(Accidental::Sharp),
            _ =&gt; Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                format!(&quot;{} is not a valid accidental&quot;, s),
            )),
        }
    }
}
</code></pre>
<p>There is third accidental called &quot;natural&quot;, <code>♮</code>, which cancels these out.  To represent a pitch in data we don't need it - we can get each of the piano keys with just <code>Accidental::Sharp</code>.  We really just include <code>Accidental::Flat</code> for a smooth user experience - people expect those to be valid notes, even though they represent the same pitch.  The natural symbol is generally used for overriding a <a href="https://en.wikipedia.org/wiki/Key_signature">key signature</a>, which defines the default accidental for all the notes within a scale on <a href="https://en.wikipedia.org/wiki/Staff_(music)">sheet music</a>.  There are a series of accidentals on the margin of the staff that apply to all notes, which is how we ensure we play notes within a single given scale, or <a href="https://en.wikipedia.org/wiki/Key_(music)">key</a>.  However, you may choose to compose a melody that contains a note outside this key.  If encounter the note <code>F#♮</code> on your sheet, you play an F.  This program isn't (yet) smart enough to work with these.</p>
<p>Now we can finally define a specific tone on a full piano.  A standard pitch, in our program a <code>PianoKey</code>, is composed of two components: a <code>Note</code> and a 0-indexed octave:</p>
<pre><code class="language-rust">#[derive(Default, Debug, Clone, Copy, PartialEq)]
pub struct PianoKey {
    note: Note,
    octave: u8,
}
</code></pre>
<p>To show them, we just want to print them out next to each other:</p>
<pre><code class="language-rust">impl fmt::Display for PianoKey {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;{}{}&quot;, self.note, self.octave)
    }
}
</code></pre>
<p>This one also has a little more logic to pull out of a string, building from the constituent components:</p>
<pre><code class="language-rust">impl FromStr for PianoKey {
    type Err = io::Error;

    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        // It makes sense to get the letter to Intervals
        if let Some(octave) = char_strs(s).last() {
            if let Ok(octave) = octave.parse::&lt;u8&gt;() {
                let note = Note::from_str(&amp;s[0..s.len() - 1])?;
                if octave &lt;= Self::max_octave() {
                    Ok(Self { note, octave })
                } else {
                    Err(io::Error::new(
                        io::ErrorKind::InvalidInput,
                        format!(&quot;{} is too high!&quot;, octave),
                    ))
                }
            } else {
                Err(io::Error::new(
                    io::ErrorKind::InvalidInput,
                    format!(&quot;{} is too high for this keyboard&quot;, octave),
                ))
            }
        } else {
            Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                format!(&quot;{} is not a valid note&quot;, s),
            ))
        }
    }
}
</code></pre>
<p>The octave just starts at 0 and won't ever realistically rise above 255, so a <code>u8</code> is fine.  We can give ourselves a few convenience methods:</p>
<pre><code class="language-rust">impl PianoKey {
    pub fn new(s: &amp;str) -&gt; Result&lt;Self, io::Error&gt; {
        Self::from_str(s)
    }
    fn max_octave() -&gt; u8 {
        8
    }
}
</code></pre>
<p>Thanks to all the nested <code>Default</code> blocks, the <code>Default</code> implementation that the compiler derives for <code>PianoKey</code> corresponds to the official base pitch of this system, <code>C0</code>, specified in the first assertion of the test.  Speaking of which, <code>test_new_pitch()</code> should now pass.</p>
<h5>Intervals</h5>
<p>The cyan key is Middle C, and A440 is highlighted in yellow.  The octaves on an 88-key piano are numbered as shown, so often A440 is simply denoted &quot;A4&quot; especially when dealing with a keyboard.  You may own a tuner that marks 440Hz/A4 specifically if you're a musician.  This pitch is used for calibrating musical instruments and tuning a group, as well as a baseline constant for calculating frequencies.</p>
<p>Note how each octave starts at C, not A, so A4 is actually higher in pitch than C4.  Octaves are &quot;C-indexed&quot; and base 8: <code>C D E F G A B C</code> is the base unmodified scale.</p>
<p>The smallest of interval between notes on a piano (and most of Western music) is called a <a href="https://en.wikipedia.org/wiki/Semitone">semitone</a>, also called a minor second or half step.  We'll need to keep track of these as the basic unit of a keyboard interval:</p>
<pre><code class="language-rust">#[derive(Debug, Default, Clone, Copy, PartialEq)]
pub struct Semitones(i8);

impl From&lt;i8&gt; for Semitones {
    fn from(i: i8) -&gt; Self {
        Self(i)
    }
}

impl From&lt;Semitones&gt; for i8 {
    fn from(s: Semitones) -&gt; Self {
        s.0
    }
}
</code></pre>
<p>Take a look back at that piano diagram above - one semitone is the distance between two adjacent keys.  A <em>whole</em> step, or a <a href="https://en.wikipedia.org/wiki/Major_second">major second</a>, is equal to two semitones, or two adjacent white keys that pass over a black key.  To play from C4 to C5, you'll use 12 keys (count all the white and black keys in a bracket), so octaves are divided into 12 equal semitones.  There's a name for <a href="https://en.wikipedia.org/wiki/Interval_(music)#Main_intervals">each interval</a>:</p>
<pre><code class="language-rust">#[derive(Debug, Clone, Copy, PartialEq, PartialOrd)]
pub enum Interval {
    Unison = 0,
    Min2,
    Maj2,
    Min3,
    Maj3,
    Perfect4,
    Tritone,
    Perfect5,
    Min6,
    Maj6,
    Min7,
    Maj7,
    Octave,
}
</code></pre>
<p>By including a numeric index with <code>Unison = 0</code>, each variant also gets assigned the next successive ID.  This way we can refer to each by name but also get an integer corresponding to the number of semitones when needed: <code>Interval::Maj2 as i8</code> returns <code>2_i8</code>.</p>
<p>Two identical notes are called a <a href="https://en.wikipedia.org/wiki/Unison">unison</a>, with 0 cents.  These intervals are defined within a single octave, so any of them apply across octaves as well - A4 and A5 are in unison just like A4 and another A4, and C4 and A5 is still a major sixth.  The terms &quot;major&quot;, &quot;minor&quot;, and &quot;perfect&quot; are not arbitrary, but that discussion is outside the scope of this post.  I will note that the <a href="https://en.wikipedia.org/wiki/Tritone">tritone</a>, representing 3 whole tones or 6 semitones like <code>F-B</code>, is the only one that's none of the three.</p>
<p>If interested, I recommend <a href="https://en.wikipedia.org/wiki/Harmony">harmony</a> for your next rabbit hole.  The tritone takes a leading role in <a href="https://en.wikipedia.org/wiki/Consonance_and_dissonance">dissonance</a>, and to hear it in action you should check out what the <a href="https://en.wikipedia.org/wiki/Locrian_mode">Locrian mode</a> we defined sounds like with this program.  The C major scale has a perfect fifth, 5 semitones at the <a href="https://en.wikipedia.org/wiki/Dominant_(music)">dominant</a> scale <a href="https://en.wikipedia.org/wiki/Degree_(music)">degree</a> - and the Locrian mode has a tritone which is one extra semitone.</p>
<p>These all map to numbers, but we don't want to have to think about the rules when adding and subtracting.  Let's do a little plumbing:</p>
<pre><code class="language-rust">#[test]
fn test_add_interval() {
    use Interval::*;
    assert_eq!(Unison + Unison, Unison);
    assert_eq!(Unison + Maj3, Maj3);
    assert_eq!(Maj2 + Min3, Perfect4);
    assert_eq!(Octave + Octave, Unison);
    assert_eq!(Tritone + Tritone, Unison);
    assert_eq!(Maj7 + Min3, Maj2);
}

#[test]
fn test_sub_interval() {
    use Interval::*;
    assert_eq!(Unison - Unison, Unison);
    assert_eq!(Unison - Maj3, Min6);
    assert_eq!(Maj2 - Min3, Maj7);
    assert_eq!(Octave - Octave, Unison);
    assert_eq!(Tritone - Tritone, Unison);
    assert_eq!(Maj7 - Min3, Min6);
}
</code></pre>
<p>First, a little plumbing:</p>
<pre><code class="language-rust">impl From&lt;Interval&gt; for i8 {
    fn from(i: Interval) -&gt; Self {
        Semitones::from(i).into()
    }
}

impl From&lt;Semitones&gt; for Interval {
    fn from(s: Semitones) -&gt; Self {
        use Interval::*;
        let int_semitones = i8::from(s);
        match int_semitones {
            0 =&gt; Unison,
            1 =&gt; Min2,
            2 =&gt; Maj2,
            3 =&gt; Min3,
            4 =&gt; Maj3,
            5 =&gt; Perfect4,
            6 =&gt; Tritone,
            7 =&gt; Perfect5,
            8 =&gt; Min6,
            9 =&gt; Maj6,
            10 =&gt; Min7,
            11 =&gt; Maj7,
            12 | _ =&gt; Interval::from(Semitones(int_semitones % Octave as i8)),
        }
    }
}

impl From&lt;Interval&gt; for Semitones {
    fn from(i: Interval) -&gt; Self {
        Semitones(i as i8)
    }
}
</code></pre>
<p>Now we can define <code>Add</code> and <code>Sub</code>:</p>
<pre><code class="language-rust">use std::ops::{Add, Sub};

impl Add for Interval {
    type Output = Self;
    fn add(self, rhs: Self) -&gt; Self {
        Interval::from(Semitones(
            i8::from(self) + i8::from(rhs) % Interval::Octave as i8,
        ))
    }
}

impl Sub for Interval {
    type Output = Self;
    fn sub(self, rhs: Self) -&gt; Self {
        let mut delta = i8::from(self) - i8::from(rhs);
        if delta &lt; 0 {
            delta += Interval::Octave as i8;
        };
        Interval::from(Semitones(delta))
    }
}
</code></pre>
<p>That gets us <code>+</code> and <code>-</code>, but we're going to want <code>+=</code> later too and that's really easy now:</p>
<pre><code class="language-rust">use std::ops::AddAssign;

impl AddAssign for Interval {
    fn add_assign(&amp;mut self, rhs: Self) {
        *self = *self + rhs;
    }
}
</code></pre>
<p>We can also relate Notes to Intervals pretty well:</p>
<pre><code class="language-rust">#[test]
fn test_get_note_interval_from_c() {
    use Interval::*;
    assert_eq!(Note::from_str(&quot;A&quot;).unwrap().interval_from_c(), Maj6);
    assert_eq!(Note::from_str(&quot;A#&quot;).unwrap().interval_from_c(), Min7);
    assert_eq!(Note::from_str(&quot;Bb&quot;).unwrap().interval_from_c(), Min7);
    assert_eq!(Note::from_str(&quot;B&quot;).unwrap().interval_from_c(), Maj7);
    assert_eq!(Note::from_str(&quot;C&quot;).unwrap().interval_from_c(), Unison);
    assert_eq!(Note::from_str(&quot;C#&quot;).unwrap().interval_from_c(), Min2);
    assert_eq!(Note::from_str(&quot;D&quot;).unwrap().interval_from_c(), Maj2);
    assert_eq!(Note::from_str(&quot;D#&quot;).unwrap().interval_from_c(), Min3);
    assert_eq!(Note::from_str(&quot;E&quot;).unwrap().interval_from_c(), Maj3);
    assert_eq!(Note::from_str(&quot;F&quot;).unwrap().interval_from_c(), Perfect4);
    assert_eq!(Note::from_str(&quot;F#&quot;).unwrap().interval_from_c(), Tritone);
    assert_eq!(Note::from_str(&quot;G&quot;).unwrap().interval_from_c(), Perfect5);
    assert_eq!(Note::from_str(&quot;G#&quot;).unwrap().interval_from_c(), Min6);
}

#[test]
fn test_get_note_offset() {
    use Interval::*;
    let a = Note::from_str(&quot;A&quot;).unwrap();
    assert_eq!(Note::from_str(&quot;A&quot;).unwrap().get_offset(a), Unison);
    assert_eq!(Note::from_str(&quot;A#&quot;).unwrap().get_offset(a), Min2);
    assert_eq!(Note::from_str(&quot;B&quot;).unwrap().get_offset(a), Maj2);
    assert_eq!(Note::from_str(&quot;C&quot;).unwrap().get_offset(a), Min3);
    assert_eq!(Note::from_str(&quot;C#&quot;).unwrap().get_offset(a), Maj3);
    assert_eq!(Note::from_str(&quot;D&quot;).unwrap().get_offset(a), Perfect4);
    assert_eq!(Note::from_str(&quot;D#&quot;).unwrap().get_offset(a), Tritone);
    assert_eq!(Note::from_str(&quot;E&quot;).unwrap().get_offset(a), Perfect5);
    assert_eq!(Note::from_str(&quot;F&quot;).unwrap().get_offset(a), Min6);
    assert_eq!(Note::from_str(&quot;F#&quot;).unwrap().get_offset(a), Maj6);
    assert_eq!(Note::from_str(&quot;G&quot;).unwrap().get_offset(a), Min7);
    assert_eq!(Note::from_str(&quot;G#&quot;).unwrap().get_offset(a), Maj7);
}

#[test]
fn test_add_interval_to_note() {
    use Interval::*;
    let a = Note::from_str(&quot;A&quot;).unwrap();
    assert_eq!(a + Unison, a);
    assert_eq!(a + Min2, Note::from_str(&quot;A#&quot;).unwrap());
    assert_eq!(a + Maj2, Note::from_str(&quot;B&quot;).unwrap());
    assert_eq!(a + Min3, Note::from_str(&quot;C&quot;).unwrap());
    assert_eq!(a + Maj3, Note::from_str(&quot;C#&quot;).unwrap());
    assert_eq!(a + Perfect4, Note::from_str(&quot;D&quot;).unwrap());
    assert_eq!(a + Tritone, Note::from_str(&quot;D#&quot;).unwrap());
    assert_eq!(a + Perfect5, Note::from_str(&quot;E&quot;).unwrap());
    assert_eq!(a + Min6, Note::from_str(&quot;F&quot;).unwrap());
    assert_eq!(a + Maj6, Note::from_str(&quot;F#&quot;).unwrap());
    assert_eq!(a + Min7, Note::from_str(&quot;G&quot;).unwrap());
    assert_eq!(a + Maj7, Note::from_str(&quot;G#&quot;).unwrap());
}
</code></pre>
<p>This all works with the logic we've already modelled:</p>
<pre><code class="language-rust">impl From&lt;Interval&gt; for Note {
    // Take an interval from C
    fn from(i: Interval) -&gt; Self {
        use Interval::*;
        let mut offset = Unison;
        // That's a series of Min2
        let scale = Scale::Chromatic.get_intervals();
        scale.iter().take(i as usize).for_each(|i| offset += *i);
        Note::default() + offset
    }
}

impl Add&lt;Interval&gt; for Note {
    type Output = Self;

    fn add(self, rhs: Interval) -&gt; Self {
        let semitones = Semitones::from(rhs);
        let mut ret = self;
        for _ in 0..i8::from(semitones) {
            ret.inc();
        }
        ret
    }
}

impl AddAssign&lt;Interval&gt; for Note {
    fn add_assign(&amp;mut self, rhs: Interval) {
        *self = *self + rhs;
    }
}
</code></pre>
<p>For <code>Add&lt;Interval&gt; for Note</code> to work, we need to add some extra helper methods:</p>
<pre><code class="language-rust">impl NoteLetter {
    // ..
    fn inc(self) -&gt; Self {
        use NoteLetter::*;
        match self {
            C =&gt; D,
            D =&gt; E,
            E =&gt; F,
            F =&gt; G,
            G =&gt; A,
            A =&gt; B,
            B =&gt; C,
        }
    }
}

impl Note {
    fn interval_from_c(self) -&gt; Interval {
        use Accidental::*;
        let ret = self.letter.interval_from_c();
        if let Some(acc) = self.accidental {
            match acc {
                Flat =&gt; return Interval::from(Semitones::from(i8::from(Semitones::from(ret)) - 1)),
                Sharp =&gt; return ret + Interval::Min2,
            }
        };
        ret
    }
    fn get_offset_from_interval(self, other: Interval) -&gt; Interval {
        let self_interval_from_c = self.interval_from_c();
        self_interval_from_c - other
    }
    fn get_offset(self, other: Self) -&gt; Interval {
        let self_interval_from_c = self.interval_from_c();
        let other_interval_from_c = other.interval_from_c();
        self_interval_from_c - other_interval_from_c
    }
    fn inc(&amp;mut self) {
        use Accidental::*;
        use NoteLetter::*;
        if let Some(acc) = self.accidental {
            self.accidental = None;
            match acc {
                Sharp =&gt; {
                    self.letter = self.letter.inc();
                }
                Flat =&gt; {}
            }
        } else {
            // check for special cases
            if self.letter == B || self.letter == E {
                self.letter = self.letter.inc();
            } else {
                self.accidental = Some(Sharp);
            }
        }
    }
}
</code></pre>
<p>Hold on, though - this won't compile yet.  The <code>impl From&lt;Interval&gt; for Note</code> block depends on the intervals for <code>Scale::Chromatic</code>, and we haven't talked about scales yet.</p>
<h5>Scales</h5>
<p><em><a href="#table-of-contents">top</a></em></p>
<p>A <a href="https://en.wikipedia.org/wiki/Scale_(music)">scale</a> is a series of notes (frequencies) defined in terms of successive intervals from a base note.  We'll start with the <a href="https://en.wikipedia.org/wiki/Major_scale">major scale</a>:</p>
<pre><code class="language-rust">#[derive(Debug, Clone, Copy, PartialEq)]
pub enum Scale {
    Major,
}

impl Default for Scale {
    fn default() -&gt; Self {
        Scale::Major
    }
}
</code></pre>
<p>Clearly, there isn't a black key between every white key - there must be a method to the madness.  The piano is designed to play notes from a category of scales called <a href="https://en.wikipedia.org/wiki/Diatonic_scale">diatonic scales</a>, where the full range of an octave consists of five whole steps and two half steps.  That's why our <code>NoteLetter</code> indices needed some extra logic - while each pair of adjacent keys is one semitone, that doesn't always mean a white key to a black key or vice versa - the note pairs B/C and E/F are both only separated by one semitone.</p>
<p>We can see this visually on the keyboard - it has the same 8-length whole/half step pattern all the way through.  The distribution pattern begins on C, but the keyboard itself starts at A0 and ends at C8.  A piano is thus designed because it can play music across the full range of diatonic scales.  This is where we get those base 8 sequences - just start on a different note.</p>
<p>That base pattern is the C <a href="https://en.wikipedia.org/wiki/Major_scale">major scale</a>.  Start at Middle C, the one highlighted in cyan above, and count up to the next C key, eight white keys to the left.  Each time you skip a black key is a whole step and if the two white keys are adjacent it's a half step.  These are the steps you get counting up to the next C, when the pattern repeats.  This totals 12 semitones per octave:</p>
<pre><code class="language-txt">whole, whole, half, whole, whole, whole, half
  2  +  2   +  1  +   2   +  2  +   2  +  1   =  12
C    D     E      F       G      A     B     C
</code></pre>
<p>We can hardcode this sequence in Rust as a <code>Vec&lt;Interval&gt;</code>:</p>
<pre><code class="language-rust">impl Scale {
    fn get_intervals(self) -&gt; Vec&lt;Interval&gt; {
        use Interval::*;
        use Scale::*;
        match self {
            Major =&gt; vec![Maj2, Maj2, Min2, Maj2, Maj2, Maj2, Min2],
        }
    }
}
</code></pre>
<p>We need a method to map to exact intervals:</p>
<pre><code class="language-rust">#[test]
fn test_note_letter_to_interval() {
    use Interval::*;
    use NoteLetter::*;
    assert_eq!(C.interval_from_c(), Unison);
    assert_eq!(D.interval_from_c(), Maj2);
    assert_eq!(E.interval_from_c(), Maj3);
    assert_eq!(F.interval_from_c(), Perfect4);
    assert_eq!(G.interval_from_c(), Perfect5);
    assert_eq!(A.interval_from_c(), Maj6);
    assert_eq!(B.interval_from_c(), Maj7);
}
</code></pre>
<p>Check out that interval sequence - we've seen something like this somewhere before:</p>
<pre><code class="language-bash">split(&quot;0,2,4,5,7,9,11,12&quot;,a,&quot;,&quot;);
</code></pre>
<p>Aha!  It's was a major scale over one octave this whole time, as a series of semitone offsets:</p>
<pre><code class="language-txt">whole, whole, half, whole, whole, whole, half
  2  +  2   +  1  +   2   +  2  +   2  +  1
0    2     4      5      7      9     11     12
Un. Min2  Maj2  Perf4  Perf5   Maj6 Maj7   Octave
A4    B4   C#5    D5     E5    F#5   G#5    A5
</code></pre>
<p>Luckily <em>we already told Rust about this</em> when we defined the major scale.  Now our modelling efforts are finally beginning to pay off:</p>
<pre><code class="language-rust">impl NoteLetter {
    fn interval_from_c(self) -&gt; Interval {
        use Interval::Unison;
        Scale::default()
            .get_intervals()
            .iter()
            .take(self as usize)
            .fold(Unison, |acc, i| acc + *i)
    }
}
</code></pre>
<p>We can work with scales using the Rust <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">iterator methods</a>!  This function takes the first n intervals of a scale, and then uses the special <code>impl Add for Interval</code> logic we defined to total everything up.  For instance, to calculate <code>F</code>, this function grabs the first 3 intervals, <code>[Maj2, Maj2, Min2]</code>, and then sums them up, using <code>Unison</code>, or 0, as the base.  This calculates the sum of <code>[2,2,1]</code>, which is <code>5</code> semitones, or <code>Interval::Perfect4</code>.</p>
<p>Doing the same exercise with the same intervals starting on a different while key will also produce a major scale but you will start using the black keys to do so.  C is the note that allows you to stick to only white keys with this interval pattern, or has no sharps or flats in the key signature.  Before we start generating sequences of notes, though, we need a way to represent a note.</p>
<h5>Key</h5>
<p><em><a href="#table-of-contents">top</a></em></p>
<p>For context, once again here's the original line we're dealing with:</p>
<pre><code class="language-bash">split(&quot;0,2,4,5,7,9,11,12&quot;,a,&quot;,&quot;);
</code></pre>
<p>We've now discovered that that list represents the list of semitone offsets from A4 that represent an A major scale.  The random notes that get produced will all be frequencies that correspond to these offsets from 440Hz.</p>
<p>We way, way overshot this in the process of modelling the domain.  We can now automatically generate sequences of <code>PianoKey</code> structs that correspond to keys on an 88-key piano to select from: <code>[C4 D4 E4 F4 G4 A5 B5 C5]</code>.  If we want a different scale, we can just ask.</p>
<p>We don't necessarily want to stick within a single octave, though. We want to make available the full 108 keys from C0 to B8 (even larger than the standard piano from the diagram), letting the user decide how many octaves to pick from, but only use notes in the key.</p>
<pre><code class="language-rust">#[derive(Debug, Default, Clone, Copy, PartialEq)]
pub struct Key {
    base_note: PianoKey,
    octaves: u8,
    scale: Scale,
}

impl Key {
    pub fn new(scale: Scale, base_note: PianoKey, octaves: u8) -&gt; Self {
        let octaves = if base_note.octave + octaves &gt; 8 {
            PianoKey::max_octave() - base_note.octave
        } else {
            octaves
        };
        Self {
            base_note,
            octaves,
            scale,
        }
    }
    fn all_keys(self) -&gt; Vec&lt;PianoKey&gt; {
            let notes = self.get_notes();
            let mut ret = Vec::new();
            for i in 0..self.octaves {
                notes.iter().for_each(|n| {
                    ret.push(
                        PianoKey::from_str(&amp;format!(&quot;{}{}&quot;, *n, i + self.base_note.octave)).unwrap_or_else(|_|
                            PianoKey::from_str(&amp;format!(&quot;{}{}&quot;, *n, PianoKey::max_octave())).unwrap(),
                        ),
                    )
                });
            }
            ret
        }
}
</code></pre>
<p>These will be displayed as simply the octave-less notes in the scale:</p>
<pre><code class="language-rust">#[test]
fn test_c_major() {
    assert_eq!(
        &amp;Key::new(Scale::default(), PianoKey::default(), 1).to_string(),
        &quot;[ C D E F G A B C ]&quot;
    )
}

#[test]
fn test_a_major() {
    assert_eq!(
        &amp;Key::new(Scale::default(), PianoKey::from_str(&quot;A4&quot;).unwrap(), 1).to_string(),
        &quot;[ A B C# D E F# G# A ]&quot;
    )
}

#[test]
fn test_g_major() {
    assert_eq!(
        &amp;Key::new(Scale::default(), PianoKey::from_str(&quot;G4&quot;).unwrap(), 1).to_string(),
        &quot;[ G A B C D E F# G ]&quot;
    )
}
</code></pre>
<p>To produce all the notes in a given key, we need to calculate them from the scale and the base note:</p>
<pre><code class="language-rust">impl Key {
    // ..
    pub fn get_notes(self) -&gt; Vec&lt;Note&gt; {
        let mut ret = vec![self.base_note.note];
        let mut offset = Interval::Unison;
        self.scale.get_intervals().iter().for_each(|i| {
            offset += *i;
            ret.push(self.base_note.note + offset)
        });
        ret
    }
}
</code></pre>
<pre><code class="language-rust">impl fmt::Display for Key {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        let notes = self.get_notes();
        let mut ret = String::from(&quot;[ &quot;);
        notes.iter().for_each(|n| ret.push_str(&amp;format!(&quot;{} &quot;, *n)));
        ret.push_str(&quot;]&quot;);
        write!(f, &quot;{}&quot;, ret)
    }
}
</code></pre>
<p>This uses the <code>impl Add for Interval</code> logic we'd previous defined to count up successive intervals across a scale, resulting in a more concrete set of notes.  Now we can add the <code>Display</code> implementation used in the test code -  this trait also provides the <code>to_string()</code> method:</p>
<pre><code class="language-rust">impl fmt::Display for Key {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        let notes = self.get_notes();
        let mut ret = String::from(&quot;[ &quot;);
        notes.iter().for_each(|n| ret.push_str(&amp;n.to_string()));
        ret.push_str(&quot;]&quot;);
        write!(f, &quot;{}&quot;, ret)
    }
}
</code></pre>
<h5>Circle of Fifths</h5>
<p><em><a href="#table-of-contents">top</a></em></p>
<p>With <code>Key</code> defined, we can start talking about other scales.</p>
<p>Using the same intervals as the C major scale starting on a different note will also produce a major scale but you will start using the black keys.  This is called the key signature, and there's one for each variant of the major scale starting from each black key.  They're related by the <a href="https://en.wikipedia.org/wiki/Circle_of_fifths">circle of fifths</a>:</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/3/33/Circle_of_fifths_deluxe_4.svg" alt="circle" /></p>
<p>The C major scale has all white keys.  To find the version of the major scale that adds one single black key to augment a tone, you go up a perfect fifth, or 7 semitones: <a href="https://en.wikipedia.org/wiki/Perfect_fifth"><code>Interval::Perfect5</code></a>.  This has a ratio 3:2.</p>
<p>One perfect fifth up from <code>C</code> is <code>G</code>, so the next scale around the circle is <a href="https://en.wikipedia.org/wiki/G_major">G major</a>.  It has one sharp: A.  Go <a href="#a-little-music-theory">back up</a> to the piano diagram and count up the major scale sequence from G, for example one note below the yellow A4.  You'll need the <code>F#</code> black key at the last step right before G5, but all the other hops white stick to the white keys.  <a href="https://en.wikipedia.org/wiki/D_major">D major</a> will need two black keys, <code>F#</code> and <code>C#</code>.  If you continue incrementing a fifth (remember, octave is irrelevant here), you'll hit all 12 possible patterns before getting back to C.  To get through all the key signatures incrementally, one accidental at a time, you keep going up by perfect fifths.  Once you come all the way back to C, you'll have hit all 12 keys, encompassing all possible key signatures.</p>
<p>This diagram also shows the <a href="https://en.wikipedia.org/wiki/Relative_key">relative natural minor</a> for each.  That's a sneak preview of the Aeolian mode in the next section!</p>
<p>It's true that, e.g. <code>D#</code> and <code>E♭</code> represent the same pitch - what's different is why we got there.  After the midway point, it's easier to denote 5 flats than 7 sharps, even though they mean the same tones - there's only 5 black keys to choose from, after all.</p>
<p>To go counter-clockwise, go up by a perfect fourth every time, which is 5 semitones.  This is known as &quot;circle of fourths&quot;, and is more commonly associated with <a href="https://en.wikipedia.org/wiki/Jazz">jazz</a> music whereas fifths are seen in more <a href="https://en.wikipedia.org/wiki/Classical_music">classical</a> contexts.</p>
<p>This program doens't use it, but we can generate all of them by just passing each note into <code>Key::new()</code>:</p>
<pre><code class="language-rust">impl Scale {
    pub fn circle_of_fifths() -&gt; Vec&lt;Key&gt; {
        let mut ret = Vec::new();
        // Start with C
        let mut current_base = Note::default();
        // Increment by fifths and push to vector
        for _ in 0..ScaleLength::Dodecatonic as usize {
            ret.push(Key::new(Scale::default(), &amp;current_base.to_string()));
            current_base += Interval::Perfect5;
        }
        ret
    }
}
</code></pre>
<p>That's twelve scales for free:</p>
<pre><code class="language-txt">[ C D E F G A B C ]
[ G A B C D E F# G ]
[ D E F# G A B C# D ]
[ A B C# D E F# G# A ]
[ E F# G# A B C# D# E ]
[ B C# D# E F# G# A# B ]
[ F# G# A# B C# D# F F# ]
[ C# D# F F# G# A# C C# ]
[ G# A# C C# D# F G G# ]
[ D# F G G# A# C D D# ]
[ A# C D D# F G A A# ]
[ F G A A# C D E F ]
</code></pre>
<p>This implementation isn't smart enough to switch to flats halfway through to represent the black keys used - could be a fun mini-challenge!  Maybe you could extend this to hop to different scales around the circle periodically.</p>
<h5>Diatonic Modes</h5>
<p><em><a href="#table-of-contents">top</a></em></p>
<p>Now we can produce the 12 transpositions of major scale from C - just pick any note of the keyboard and count up the same intervals.  However, this pattern of white and black repeats all the way up and down the whole length of the keyboard - what if we didn't start at C to set the base of the black-key/white-key pattern?  Why not use <code>A B C D E F G A</code>?</p>
<p>If you start on any other white key and count up one octave skipping all the black keys, you will get a <em>different</em> diatonic scale than a major scale.  These scale variations are called <a href="https://en.wikipedia.org/wiki/Mode_(music)#Modern_modes">Modes</a>, and while high-school me was terrified of and terrible at whipping out arbitrary ones on a brass instrument from memory (mental math is <em>not</em> one of my talents), they're easy to work with programmatically (and much less stressful).</p>
<p>The major scale is also known as the <a href="https://en.wikipedia.org/wiki/Ionian_mode">Ionian mode</a>.  This is the base mode, each other is some offset from this scale.  As we've seen, the key you need to start on to play this mode with no black keys (accidentals) is C.</p>
<p>The natural minor scale, is obtained by starting at A4 and counted up white keys, is called the <a href="https://en.wikipedia.org/wiki/Aeolian_mode">Aeolian mode</a>.  Try it yourself on the diagram - march on up the white keys from A4 to A5:</p>
<pre><code class="language-txt">whole, half, whole, whole, half, whole, whole
</code></pre>
<p>This should look like the C major scale, no sharps or flats, but with <code>A</code> at the beginning:</p>
<pre><code class="language-rust">#[test]
fn test_a_minor() {
    use Mode::*;
    use Scale::*;
    assert_eq!(
        &amp;Key::new(Diatonic(Aeolian), PianoKey::from_str(&quot;A4&quot;).unwrap(), 1).to_string(),
        &quot;[ A B C D E F G A ]&quot;
    )
}
</code></pre>
<p>It's the same pattern, just starting at a different offset.  You can play a corresponding minor scale using only the white keys by simply starting at the sixth note of the C major scale (or incrementing a major sixth), which is A.  Try counting it out yourself up from A4.</p>
<p>There's an absurdly fancy name for each offset:</p>
<pre><code class="language-rust">#[derive(Debug, Clone, Copy, PartialEq, PartialOrd)]
pub enum Mode {
    Ionian = 0,
    Dorian,
    Phrygian,
    Lydian,
    Mixolydian,
    Aeolian,
    Locrian,
}
</code></pre>
<p>We'll hardcode the C major sequence as the base:</p>
<pre><code class="language-txt">whole, whole, half, whole, whole, whole, half
  2  +  2   +  1  +   2   +  2  +   2  +  1
</code></pre>
<pre><code class="language-rust">impl Mode {
    fn base_intervals() -&gt; Vec&lt;Interval&gt; {
        use Interval::*;
        vec![Maj2, Maj2, Min2, Maj2, Maj2, Maj2, Min2]
    }
}
</code></pre>
<p>Let's also hardcode the scale length:</p>
<pre><code class="language-rust">#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ScaleLength {
    Heptatonic = 7,
}
</code></pre>
<p>Now we can make our scales a little smarter:</p>
<pre><code class="language-diff">  #[derive(Debug, Clone, Copy, PartialEq)]
  pub enum Scale {
-     Major,
      Diatonic(Mode),
  }

  impl Default for Scale {
      fn default() -&gt; Self {
-         Scale::Major
+         Scale::Diatonic(Mode)
      }
  }

  impl Scale {
    fn get_intervals(self) -&gt; Vec&lt;Interval&gt; {
            use Interval::*;
            use Scale::*;
            match self {
-               Major =&gt; vec![Maj2, Maj2, Min2, Maj2, Maj2, Maj2, Min2],
+               Diatonic(mode) =&gt; Mode::base_intervals()
+                   .iter()
+                   .cycle()
+                   .skip(mode as usize)
+                   .take(ScaleLength::Heptatonic as usize)
+                   .copied()
+                   .collect::&lt;Vec&lt;Interval&gt;&gt;(),
+           }
        }
  }
</code></pre>
<p>Now we've got seven modes for each of twelve keys on the keyboard - that's 84 distinct key signatures.  The <code>Ionian</code> and <code>Aeolian</code> modes have nicknames, the rest we'll just work with as the mode names:</p>
<pre><code class="language-rust">impl FromStr for Scale {
    type Err = io::Error;
    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        use Mode::*;
        use Scale::*;
        match s.to_uppercase().as_str() {
            &quot;IONIAN&quot; | &quot;MAJOR&quot; =&gt; Ok(Diatonic(Ionian)),
            &quot;DORIAN&quot; =&gt; Ok(Diatonic(Dorian)),
            &quot;PHRYGIAN&quot; =&gt; Ok(Diatonic(Phrygian)),
            &quot;LYDIAN&quot; =&gt; Ok(Diatonic(Lydian)),
            &quot;MIXOLYDIAN&quot; =&gt; Ok(Diatonic(Mixolydian)),
            &quot;AEOLIAN&quot; | &quot;MINOR&quot; =&gt; Ok(Diatonic(Aeolian)),
            &quot;LOCRIAN&quot; =&gt; Ok(Diatonic(Locrian)),
            _ =&gt; Err(io::Error::new(io::ErrorKind::InvalidInput, &quot;Unknown scale&quot;)),
        }
    }
}

impl fmt::Display for Scale {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        use Scale::*;
        let s = match self {
            Diatonic(mode) =&gt; {
                use Mode::*;
                match mode {
                    Aeolian =&gt; &quot;minor scale&quot;.into(),
                    Ionian =&gt; &quot;major scale&quot;.into(),
                    _ =&gt; format!(&quot;{:?} mode&quot;, mode),
                }
            }
        };
        write!(f, &quot;{}&quot;, s)
    }
}
</code></pre>
<p>The fact that Ionian Mode/C Major is Offset 0 is actually somewhat arbitrary - though definitely not completely.  There's a reason C major is so commonly found in music - it sounds good.</p>
<p>I did a <a href="https://lmgtfy.com/?q=why+does+it+start+from+C+not+A">bare-minimum</a> amount of research and found it's an <a href="https://music.stackexchange.com/questions/893/why-is-c-the-base-note-of-standard-notation-and-keys">&quot;unfortunate historical accident&quot;</a>.  In a sentence, the concept of &quot;mode&quot; in an equally tempered system predates the modern scales and <code>C == 0</code> is a historical artifact.  The letters were originally numbered from A, of course, but got mapped to frequencies well before the modern modes we use now were honed and refined from previous systems.  The system eventually came to be based around the <a href="https://en.wikipedia.org/wiki/C_major">C major scale</a>, not A major.  By then the fact that what's now Middle C was 261.626Hz was long done and over with.</p>
<h5>Non Heptatonic Scales</h5>
<p><em><a href="#table-of-contents">top</a></em></p>
<p>Okay, Ben.  Ben, okay.  Okay, Ben.  We've arrived at the version from the blog post, great.  You also promised 86 in the introduction, not 84.  This whole time, though, the line from the meme image has had something different:</p>
<pre><code class="language-bash">split(&quot;4,5,7,11&quot;,a,&quot;,&quot;);
</code></pre>
<p>The diatonic scales we've been working with are a subset of the <a href="https://en.wikipedia.org/wiki/Heptatonic_scale">heptatonic scales</a>, with seven notes each.  These tones are naturally further apart than we've been using.  Let's add a couple others scale lengths to play with:</p>
<pre><code class="language-diff">  #[derive(Debug, Clone, Copy, PartialEq)]
  pub enum ScaleLength {
+     Tetratonic = 4,
      Heptatonic = 7,
+     Dodecatonic = 12,
  }
</code></pre>
<p>Interestingly, the scale shown is <a href="https://en.wikipedia.org/wiki/Tetratonic_scale">tetratonic</a>, given as octave-less notes, intervals from base, and offsets from A440:</p>
<pre><code class="language-txt">[C#, D, E, G#]
[Min2, Maj2, Maj3]
[4, 5, 7, 11]
</code></pre>
<p>Oddly, this scale is primarily associated with pre-historic music and not often found since.  Was <code>AWK</code> passed down from the before-times? I also don't understand how that snippet works, because it's still indexed with <code>a[$1 % 8]</code>, but I'm too lazy to find out why.</p>
<p>The only dodecatonic scale is the <a href="https://en.wikipedia.org/wiki/Chromatic_scale">chromatic scale</a> is just all the notes:</p>
<pre><code class="language-txt">[A, A#, B, C, C#, D, D#, E, F, F#, G, G#]
[Min2, Min2, Min2, Min2, Min2, Min2, Min2, Min2, Min2, Min2, Min2]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
</code></pre>
<p>Who needs key signatures anyhow, that's a waste of all these other keys!  This one throws 'em all in the mix.</p>
<pre><code class="language-rust">#[derive(Debug, Clone, Copy, PartialEq)]
pub enum Scale {
    Chromatic,
    // ..
}
</code></pre>
<p>The chromatic scale is for people who don't have time to muck about with petty concerns like sounding good, and don't want to waste any piano keys - it's just 11 successive minor 2nds, giving you every note.</p>
<pre><code class="language-txt">half, half, half, half, half, half, half, half, half, half, half
A    A#    B     C     C#    D     D#    E     F     F#    G    G#
</code></pre>
<p>Or, in Rust:</p>
<pre><code class="language-rust">#[test]
fn test_chromatic_intervals() {
    use Interval::Min2;
    assert_eq!(
        Scale::Chromatic.get_intervals(),
        vec![Min2, Min2, Min2, Min2, Min2, Min2, Min2, Min2, Min2, Min2, Min2]
    );
}
</code></pre>
<pre><code class="language-diff">  #[derive(Debug, Clone, Copy, PartialEq)]
  pub enum Scale {
+     Chromatic,
      Diatonic(Mode),
+     Tetratonic,
  }

  impl Scale {
    // ..
    fn get_intervals(self) -&gt; Vec&lt;Interval&gt; {
        use Interval::*;
        use Scale::*;
        match self {
+           Chromatic =&gt; [Min2]
+               .iter()
+               .cycle()
+               .take(ScaleLength::Dodecatonic as usize)
+               .copied()
+               .collect::&lt;Vec&lt;Interval&gt;&gt;(),
            Diatonic(mode) =&gt; Mode::base_intervals()
                .iter()
                .cycle()
                .skip(mode as usize)
                .take(ScaleLength::Heptatonic as usize)
                .copied()
                .collect::&lt;Vec&lt;Interval&gt;&gt;(),
+           Tetratonic =&gt; vec![Min2, Maj2, Maj3],
          }
      }
  }

  impl FromStr for Scale {
      type Err = io::Error;
      fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
          use Mode::*;
          use Scale::*;
          match s.to_uppercase().as_str() {
              &quot;IONIAN&quot; | &quot;MAJOR&quot; =&gt; Ok(Diatonic(Ionian)),
              &quot;DORIAN&quot; =&gt; Ok(Diatonic(Dorian)),
              &quot;PHRYGIAN&quot; =&gt; Ok(Diatonic(Phrygian)),
              &quot;LYDIAN&quot; =&gt; Ok(Diatonic(Lydian)),
              &quot;MIXOLYDIAN&quot; =&gt; Ok(Diatonic(Mixolydian)),
              &quot;AEOLIAN&quot; | &quot;MINOR&quot; =&gt; Ok(Diatonic(Aeolian)),
              &quot;LOCRIAN&quot; =&gt; Ok(Diatonic(Locrian)),
+             &quot;CHROMATIC&quot; =&gt; Ok(Chromatic),
+             &quot;TETRATONIC&quot; =&gt; Ok(Tetratonic),
              _ =&gt; Err(io::Error::new(io::ErrorKind::InvalidInput, &quot;Unknown scale&quot;)),
          }
      }
  }


  impl fmt::Display for Scale {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        use Scale::*;
        let s = match self {
+           Chromatic | Tetratonic =&gt; format!(&quot;{:?} scale&quot;, self).to_lowercase(),
            Diatonic(mode) =&gt; {
                use Mode::*;
                match mode {
                    Aeolian =&gt; &quot;minor scale&quot;.into(),
                    Ionian =&gt; &quot;major scale&quot;.into(),
                    _ =&gt; format!(&quot;{:?} mode&quot;, mode),
                }
            }
        };
        write!(f, &quot;{}&quot;, s)
    }
}
</code></pre>
<p>This could be a potential natural application of <a href="https://en.wikipedia.org/wiki/Dependent_type">dependent types</a>, a programming language feature that Rust does not support.  Few languages do.  One example is <a href="https://en.wikipedia.org/wiki/Idris_(programming_language)#Dependent_types">Idris</a>, which is like <a href="https://en.wikipedia.org/wiki/Haskell_(programming_language)">Haskell</a>++.  A dependent type codifies a type restraint that's dependent on a <em>value</em> of that type.  The linked example describes a function that appends a list of <code>m</code> elements to a list <code>n</code> which specifies as part of the return type that the returned list has length <code>n + m</code>.  A caller can then trust this fact implicitly, because the compiler won't build a binary if it's not true.  I think this could be applied here to verify that a scale's intervals method returns an octave, regardless of length.  That can be tested for in code with Rust, of course, but not encoded into the type signature directly.</p>
<p>Those are just two examples, I bet you could find some other interesting patterns on the keyboard diagram.  For instance, what happens if you ignore the white keys and <em>only</em> use the black keys?</p>
<h4>Generating Music</h4>
<p><em><a href="#table-of-contents">top</a></em></p>
<p>It's finally time to make some music.  We've now built ourselves a toolkit for working with piano keys and intervals, and a separate type for dealing with a frequency in Hertz, and they both know how to interact with the same <code>Interval</code> variants.  Now we need to get from <code>PianoKey</code> obtects to <code>Pitch</code>es.</p>
<h5>Cents</h5>
<p><em><a href="#table-of-contents">top</a></em></p>
<p>Discrete units like <code>Semitones</code> are useful for working with a keyboard, but as we know, sound is analog and continuous.  We need to subdivide these intervals even more granularly, and because of equal temperament we're free to do so at any arbitrary level.</p>
<p>Beyond the twelve 12 semitones in an octave, each semitone is divided into 100 <a href="https://en.wikipedia.org/wiki/Cent_(music)">cents</a>.  This means a full octave, representing a 2:1 ratio in frequency, spans 1200 cents, and each cent can be divided without losing the ratio as well if needed:</p>
<pre><code class="language-rust">#[derive(Debug, Default, Clone, Copy, PartialEq)]
pub struct Cents(f64);
</code></pre>
<p>We need to do a little plumbing to let ourselves work at this higher level of abstraction.  We need to be able to translate our discrete <code>Semitones</code> into <code>Cents</code> ergonomically:</p>
<pre><code class="language-rust">#[test]
fn test_semitones_to_cents() {
    assert_eq!(Cents::from(Semitones(1)), Cents(100.0));
    assert_eq!(Cents::from(Semitones(12)), Cents(1200.0));
}
</code></pre>
<p>We can give ourselves some conversions to the inner primitive:</p>
<pre><code class="language-rust">impl From&lt;f64&gt; for Cents {
    fn from(f: f64) -&gt; Self {
        Cents(f)
    }
}

impl From&lt;Cents&gt; for f64 {
    fn from(c: Cents) -&gt; Self {
        c.0
    }
}
</code></pre>
<p>Now we can encode the conversion factor:</p>
<pre><code class="language-rust">const SEMITONE_CENTS: Cents = Cents(100.0);

impl From&lt;Semitones&gt; for Cents {
    fn from(s: Semitones) -&gt; Self {
        Cents(i8::from(s) as f64 * f64::from(SEMITONE_CENTS))
    }
}
</code></pre>
<p>With that in place, we're ready to start working with intervals directly and have Rust understand them in terms of cents:</p>
<pre><code class="language-rust">#[test]
fn test_interval_to_cents() {
    use Interval::*;
    assert_eq!(Cents::from(Unison), Cents(0.0));
    assert_eq!(Cents::from(Min2), Cents(100.0));
    assert_eq!(Cents::from(Octave), Cents(1200.0));
}
</code></pre>
<p>We need <code>Interval</code> variants to map directly to <code>Semitones</code> instead of plain integers, to make sure they're always turned into <code>Cents</code> correctly:</p>
<p>With that, it's easy to map <code>Interval</code>s to <code>Cents</code>:</p>
<pre><code class="language-rust">impl From&lt;Interval&gt; for Cents {
    fn from(i: Interval) -&gt; Self {
        Semitones::from(i).into()
    }
}
</code></pre>
<p>Phew!  Lots of code, but now we can operate directly in terms of <code>Interval</code> variants or anything in between and everything stays contextually tagged.  Verify with <code>cargo test</code> that everything checks out.</p>
<p>There's one more step to get from our brand new floating point <code>Cents</code> to frequencies in <code>Hertz</code> though.  Remember how Middle C was some crazy fraction, 261.626Hz?  This is because cents are a <a href="https://en.wikipedia.org/wiki/Logarithmic_scale">logarithmic</a> unit, standardized around the point 440.0.  While a 2:1 ratio is nice and neat, we've been subdividing that arbitrarily wherever it makes sense to us.  Now the arithmetic isn't always so clean.  Doubling 440.0Hz will get 880.0Hz, but how would we add a semitone?</p>
<p>We know that to increase by one octave we double the frequency: <code>440 * 2</code>.  We'd need to increase by a 12th of what doubling the number would do for a single semitone: <code>440 * 2^(1/12)</code>.  Looks innocuous enough, but my calculator gives me 466.164, Rust gives me 466.1637615180899 - not enough to perceptually matter, but enough that it's important that the standard is the interval ratio and not the specific amount of Hertz to add or subtract.  Those amounts will only be precise in floating point decimal representations at exact octaves from the base note, because that's integral factor after multiplying by 1 in either direction, 2 or 1/2.</p>
<p>Otherwise stated, the ratio between frequencies separated by a single cent is the 1200th root of 2, or 2^(1/1200).  In decimal, it's about 1.0005777895.  You wouldn't be able to hear a distinction between two tones a single cent apart.  Using this math, it works out to just shy of 4 cents to cause an increase of 1Hz, more precisely around 3.9302 for a base frequency of 440.0.</p>
<p>Logarithmic units are helpful when the range of the y axis, in our case frequency, increases exponentially.  We know the graph of frequency to pitch does because to jump by any single octave, we double what we have - we're multiplying at each step, not adding (which results in a linear graph).  A4 is 440Hz, A5 is 880Hz, and by A6 we're already at 1,760Hz.  The graph <code>f(x) = x^2</code> looks like this:</p>
<p><img src="https://thepracticaldev.s3.amazonaws.com/i/mkh095mgcasg1soygrb7.png" alt="x_squared" /></p>
<p>A <a href="https://en.wikipedia.org/wiki/Logarithm">logarithm</a> is the inverse of an <a href="https://en.wikipedia.org/wiki/Exponentiation">exponent</a>.  Our ratio had an exponent that was &quot;1 divided by n&quot;, which is the inverse of raising something to the power of &quot;n divided by 1&quot;, such as squaring it (n=2).  This is otherwise written as an &quot;nth root&quot;, in the case of a cent <em>n</em> being 1,200.  This counteracts the rapid growing curve we get by constantly squaring the frequency into a more linear scaled subdivision between octaves:</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3f/Music_intervals_frequency_ratio_equal_tempered_pythagorean_comparison.svg/550px-Music_intervals_frequency_ratio_equal_tempered_pythagorean_comparison.svg.png" alt="cent graph" /></p>
<p>Notice it's not a straight diagonal.  We haven't removed the fact that frequencies are being multiplied, merely adjusted for it. We're taking a logarithm of something that has been squared, the frequency.  This tames the steep increase but the line is still slightly curved.</p>
<p>Fractional cents and tones are a much better way to deal with intervals than by concrete frequency deltas.  Knowing all this we can translate back to the frequency in Hertz of a desired pitch if we know both a base frequency and the number of cents to increase by:</p>
<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/920411bb22d357b13f69a76fa33557c707f7cb57" alt="cents formula" /></p>
<p>Here, <em>a</em> is the initial frequency in Hertz, <em>b</em> is the target frequency, and <em>n</em> is the number of cents by which to increase <em>a</em>.</p>
<p>Lets try to increase the standard pitch by single Hertz using the value above:</p>
<pre><code class="language-rust">#[test]
fn test_add_cents_to_pitch() {
    let mut pitch = Pitch::default();
    pitch += Cents(3.9302);
    assert_eq!(pitch, Pitch::new(Hertz(441.0)));
}
</code></pre>
<p>It looks like we're going to need to divide some <code>Cents</code>, leveraging the <code>impl From&lt;Cents&gt; for f64</code> blocks we already defined:</p>
<pre><code class="language-rust">use std::ops::Div;

impl Div for Cents {
    type Output = Self;

    fn div(self, rhs: Self) -&gt; Self {
        Cents(f64::from(self) / f64::from(rhs))
    }
}
</code></pre>
<p>This is just performing floating point division on the inner value, but keeps it wrapped up in the <code>Cents</code> context for us so we can directly use <code>Cents(x) / Cents(y)</code>.  We now know enough to manipulate a <code>Pitch</code> directly.</p>
<p>The <a href="https://doc.rust-lang.org/std/ops/trait.AddAssign.html"><code>AddAssign</code></a> trait gets us the <code>+=</code> operator, and can define it for any type we want on the right hand side:</p>
<pre><code class="language-rust">use std::ops::AddAssign

impl AddAssign&lt;Cents&gt; for Pitch {
    #[allow(clippy::suspicious_op_assign_impl)] // needed to stop clippy from yelling
    fn add_assign(&amp;mut self, rhs: Cents) {
        self.0 *= 2.0f64.powf((rhs / Cents::from(Interval::Octave)).into())
    }
}
</code></pre>
<p>Oops, we also need to <code>*=</code> an <code>f64</code> to a <code>Hertz</code>:</p>
<pre><code class="language-rust">use std::ops::MulAssign;

impl MulAssign&lt;f64&gt; for Hertz {
    fn mul_assign(&amp;mut self, rhs: f64) {
        self.0 *= rhs;
    }
}
</code></pre>
<p>Coincidentally, an <code>impl MulAssign&lt;f64&gt; for Frequency</code> in Hertz is the exact example on the official <a href="https://doc.rust-lang.org/std/ops/trait.MulAssign.html"><code>MulAssign</code></a> docs.  Their style might be better.  I don't know, you tell me?</p>
<p>If that's not quite clear, this is the exact equation shown above with a bit of extra noise.  Dividing <code>cents</code> by <code>Cents::from(Interval::Octave)</code> leaves us with a <code>Cents</code> type, per the above <code>impl Div for Cents</code> block.  However, we then want to pass the result to <code>2.0.powf(cents_ratio)</code>.  The compiler knows it's an <code>f64</code> here because we explicitly specified it with <code>2.0_f64</code> to use as a base for <a href="https://doc.rust-lang.org/std/primitive.f64.html#method.powf"><code>powf()</code></a>.</p>
<p>Sadly, though, <code>cargo test</code> tells us we have a problem:</p>
<p><img src="https://thepracticaldev.s3.amazonaws.com/i/bu70ahx1w5rfln6sa3jq.png" alt="fail float" /></p>
<p>Floating point arithmetic is not precise.  However, a delta of as much as a whole Hertz, or almost 4 cents, isn't large enough for any human to perceive.   The <a href="https://en.wikipedia.org/wiki/Just-noticeable_difference">just-noticeable difference</a> is about 5 or 6 cents, or 5*2^(1/1200).  In this type we just care that it's &quot;close enough&quot;.  At a glance we can look at those results and understand that we got where we need to be.  To convince Rust we're good to go, we can override the compiler-derived <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a> behavior for this type:</p>
<pre><code class="language-diff">- #[derive(Debug, Clone, Copy, PartialEq, PartialOrd)]
+ #[derive(Debug, Clone, Copy, PartialOrd)]
  pub struct Pitch {
       frequency: Hertz,
  }
</code></pre>
<p>We can specify a tolerance for equality in code.  I'm arbitrarily deciding that if two <code>Pitch</code> objects are within a tenth of a Hertz of each other, they're functionally equivalent:</p>
<pre><code class="language-rust">impl Hertz {
    fn abs(self) -&gt; Self {
        Self(self.0.abs())
    }
}

impl PartialEq for Pitch {
    fn eq(&amp;self, other: &amp;Pitch) -&gt; bool {
        let tolerance = Hertz(0.1);
        let difference = (self.0 - other.0).abs();
        difference &lt; tolerance
    }
}
</code></pre>
<p>There's no trait to define to get absolute values with <code>abs()</code>, but we can plop whatever method we want directly on <code>Hertz</code> too.  Now the test we wrote will pass.  Try it out!</p>
<p>Instead of adding single cents at a time, it's easier to work by semitone:</p>
<pre><code class="language-rust">#[test]
fn test_add_semitones_to_pitch() {
    use Interval::Octave;
    let mut pitch = Pitch::default();
    pitch += Semitones::from(Octave);
    assert_eq!(pitch, Pitch::new(Hertz(880.0)))
}
</code></pre>
<p>That's pretty easy with the work we've already done:</p>
<pre><code class="language-rust">impl AddAssign&lt;Semitones&gt; for Pitch {
    fn add_assign(&amp;mut self, rhs: Semitones) {
        *self += Cents::from(rhs)
    }
}
</code></pre>
<p>In fact, why not just go straight for intervals:</p>
<pre><code class="language-rust">#[test]
fn test_add_interval_to_pitch() {
    use Interval::Min2;
    let mut pitch = Pitch::default();
    pitch += Min2;
    assert_eq!(pitch, Pitch::new(Hertz(466.1)))
}
</code></pre>
<p>Naturally, this is also trivial:</p>
<pre><code class="language-rust">impl AddAssign&lt;Interval&gt; for Pitch {
    fn add_assign(&amp;mut self, rhs: Interval) {
        *self += Cents::from(rhs)
    }
}
</code></pre>
<p>Great - now we can add <code>Cents</code> to a <code>Pitch</code> and it automatically multiplies the <code>Hertz</code> correctly.  However, we're not working with <code>Pitch</code> objects to generate key signatures.  Our key signatures are sequences of <code>PianoKey</code>s.  We need to convert to and from these two systems.  Luckily, while they're based on  different core unit, the both use the same <code>Interval</code> relationship, and we can use that as a go-between.</p>
<p>It's defined at a set frequency:</p>
<pre><code class="language-rust">pub const C_ZERO: Hertz = Hertz(16.352);
</code></pre>
<p>This is super low - most humans bottom out around 20Hz.  The 88-key piano's lowest note is up at A0, a 9-semitone <a href="https://en.wikipedia.org/wiki/Major_sixth"><code>major sixth</code></a> higher.  Note how even though this is a different abstraction for working with pitches, the frequencies baked in to the standard are still pinned to the A440 scale.</p>
<p>We want to be able to convert from piano keys to pitches and have the frequencies work out for both standards:</p>
<pre><code class="language-rust">#[test]
fn test_piano_key_to_pitch() {
    assert_eq!(Pitch::from(PianoKey::new(&quot;A4&quot;).unwrap()), Pitch::default());
    assert_eq!(Pitch::from(PianoKey::default()), Pitch::new(C_ZERO));
}
</code></pre>
<p>To get there, we can add octaves and smaller intervals up from <code>C0</code> to whatever note we need;</p>
<pre><code class="language-rust">impl From&lt;PianoKey&gt; for Pitch {
    fn from(sp: PianoKey) -&gt; Self {
        use Interval::*;
        let mut ret = Pitch::new(C_ZERO);
        // Add octaves
        for _ in 0..sp.octave {
            ret += Octave;
        }
        // Add note offset
        ret += sp.note.letter.interval_from_c();
        ret
    }
}
</code></pre>
<h5>Random Notes</h5>
<p><em><a href="#table-of-contents">top</a></em></p>
<p>The only missing thing is picking what notes to play we just need to pick the notes to play.</p>
<p>Check out this section of the <a href="https://docs.rs/rodio/0.10.0/src/rodio/source/sine.rs.html#24">source code</a> from the <code>rodio</code> crate for the <code>rodio::source::SineWave</code> we used above to check our A440 tone:</p>
<pre><code class="language-rust">impl Iterator for SineWave {
    type Item = f32;

    #[inline]
    fn next(&amp;mut self) -&gt; Option&lt;f32&gt; {
        self.num_sample = self.num_sample.wrapping_add(1);

        let value = 2.0 * 3.14159265 * self.freq * self.num_sample as f32 / 48000.0;
        Some(value.sin())
    }
}
</code></pre>
<p>This <code>impl Iterator</code> block is handling the <code>for</code> loop in the cover image.  It's calculating the exact amplitude of a sine wave at some fractional point between 0 and 1.</p>
<p>The math, in other words, is <code>440.0 * Pi * (current sample / total samples)</code>, multiplied by some value, in this case <code>2.0</code>.  This code is calculating the sine wave at a given point within a cycle - for 0 to 1, there are 48,000 points to collect, so the current point is the sine wave of this frequency at whatever point we're at, stored as <code>self.num_sample</code>, between 0 and 1.</p>
<p>For some reason they've hardcoded <a href="https://en.wikipedia.org/wiki/Pi">Pi</a>, there are constants available like <a href="https://doc.rust-lang.org/std/f64/consts/constant.PI.html"><code>std::f32::consts::PI</code></a>.  I'd be interested to know if anyone would know why that's a good choice instead of relying on the language constant!</p>
<p>The <code>SineWave</code> struct reliably produces a single tone infinitely, but we want to change the pitch.  The actual wave calculation is the same, though, we just need to add some extra logic to change up the pitch being produced.</p>
<p>We can actually use the linked source code as a template to provide our own <code>rodio::Source</code> implementation to append to the <code>Sink</code>.</p>
<p>Set up a data structure to hold on to some of the hardcoded values found in the above library snipper:</p>
<pre><code class="language-rust">pub const SAMPLE_RATE: Hertz = Hertz(48_000.0);
pub type Sample = f32;

pub struct MusicMaker {
    key: Key,
    current_note: PianoKey,
    current_sample: usize,
    sample_rate: Hertz,
    volume: f32,
}

impl Default for MusicMaker {
    fn default() -&gt; Self {
        Self {
            key: Key::default(),
            current_note: PianoKey::from_str(&quot;C4&quot;).unwrap(),
            current_sample: usize::default(),
            sample_rate: SAMPLE_RATE,
            volume: 2.0,
        }
    }
}

impl MusicMaker {
    pub fn new() -&gt; Self {
        Self::default()
    }
    fn get_frequency(&amp;mut self) -&gt; Sample {
        let pitch = Pitch::from(self.current_note);
        pitch.into()
    }
}
</code></pre>
<p>To perform the wave sampling, we can actually pretty much copy-paste the <code>impl Iterator for SineWave</code> code, just using our struct's values:</p>
<pre><code class="language-rust">use std::f32::consts::PI;

impl Iterator for MusicMaker {
    type Item = Sample; // Sampled amplitude
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.current_sample = self.current_sample.wrapping_add(1); // will cycle

        let value = self.volume
            * PI
            * self.get_frequency()
            * self.current_sample as Sample
            / f64::from(self.sample_rate) as Sample;

        if self.current_sample as f64 &gt;= f64::from(self.sample_rate) {
            self.current_sample = 0;
            self.new_note();  // Hmm...
        }
        Some(value.sin())
    }
}
</code></pre>
<p>In order to use as a sound source we can pass to a <code>rodio::Sink</code>, we implement the <code>rodio::Source</code> trait, which can be implemented for any type that implements <code>Iterator</code>, so long as the <code>Item</code> associated type is valid as a sample:</p>
<pre><code class="language-rust">use core::time::Duration;
use rodio::Source;

impl Source for MusicMaker {
    #[inline]
    fn current_frame_len(&amp;self) -&gt; Option&lt;usize&gt; {
        None
    }

    #[inline]
    fn channels(&amp;self) -&gt; u16 {
        1
    }

    #[inline]
    fn sample_rate(&amp;self) -&gt; u32 {
        f64::from(self.sample_rate) as u32
    }

    #[inline]
    fn total_duration(&amp;self) -&gt; Option&lt;Duration&gt; {
        None
    }
}
</code></pre>
<p>The <code>current_frame_len()</code> and <code>total_duration()</code> bodies indicate that this source is infinite - there's no finite duration to return.  You'll need to kill the process some other way.  The <code>channels</code> method returns the number of frequencies in the signal, and we're just working with a single wave, so a single channel is all we need.</p>
<p>Now we're finally ready to call that <code>choose()</code> method on something.  First, though, we need to select a random seed from the <code>rand</code> crate.  We don't are about cryptographic soundness here, we just need random numbers, but speed is useful.  The <a href="https://docs.rs/rand/0.7.2/rand/rngs/struct.SmallRng.html"><code>rand::rngs::SmallRng</code></a> random number generator is ideal for that.  We can initialize it using <code>from_entropy()</code> to ultimately source it from the operating system - so, sorta in a roundabout way it actually is <code>dev/urandom</code>, or similar.</p>
<pre><code class="language-diff">+  use rand::{rngs::SmallRng, seq::SliceRandom, SeedableRng};

   pub struct MusicMaker {
       key: Key,
+      seed: SmallRng,
       current_note: PianoKey,
       current_sample: usize,
       sample_rate: Hertz,
       volume: f32,
}

   impl Default for MusicMaker {
       fn default() -&gt; Self {
           Self {
               key: Key::default(),
+              seed: SmallRng::from_entropy(),
               current_note: PianoKey::from_str(&quot;C4&quot;).unwrap(),
               current_sample: usize::default(),
               sample_rate: SAMPLE_RATE,
               volume: 2.0,
           }
       }
   }

   impl MusicMaker {
     pub fn new() -&gt; Self {
         Self::default()
     }
     fn get_frequency(&amp;mut self) -&gt; Sample {
         let pitch = Pitch::from(self.current_note);
         println!(&quot;{:?}&quot;, pitch);
         pitch.into()
     }
+    fn new_note(&amp;mut self) {
+        let keys = self.key.all_keys();
+        self.current_note = *keys.iter().choose(&amp;mut self.seed).unwrap();  // There it is!  This whole time
+    }
  }
</code></pre>
<p>Now our <code>MusicMaker</code> can plug right into an audio output track.  Replace your entry point <code>main()</code> function in <code>src/bin/music.rs</code> with this:</p>
<pre><code class="language-rust">fn main() {
    println!(&quot;{}&quot;, GREETING);

    let device = default_output_device().unwrap();
    let sink = Sink::new(&amp;device);
    let music = MusicMaker::new(PianoKey::new(&quot;A4&quot;).unwrap(), Scale::default(), 1);
    sink.append(music);
    sink.sleep_until_end();
}
</code></pre>
<p>Running this with <code>cargo run</code> will essentially match the output from the original <code>bash</code> one-liner.</p>
<p><img src="https://thepracticaldev.s3.amazonaws.com/i/82lipncvy6806zyjpg2r.gif" alt="sad party" /></p>
<h5>User Parameters</h5>
<p><em><a href="#table-of-contents">top</a></em></p>
<p>There are several elements of this that are tweakable - the program that runs is a little lackluster given all the capability we've defined internally.  Let's expose some options to the user at runtime.</p>
<p>Let's give a <code>base note</code>, a <code>scale</code> option, and a number of octaves to span upwards to define the valid notes, as well as a boolean to choose to instead just play a single tone:</p>
<pre><code class="language-rust">// src/bin/music.rs
use structopt::StructOpt;

/// music is a procedural single-tone melody generator
#[derive(StructOpt, Debug)]
#[structopt(name = &quot;music&quot;)]
struct Opt {
    /// Single-pitch mode
    #[structopt(short, long)]
    pitch_mode: bool,
    /// The base note to calculate the scale from
    #[structopt(short, long, default_value = &quot;C4&quot;)]
    base_note: PianoKey,
    /// The series of intervals from the base note to use per octave
    #[structopt(short, long, default_value = &quot;Ionian&quot;)]
    scale: Scale,
    /// Number of octaves over which to range, anything over 8 gets parsed as 8
    #[structopt(short, long, default_value = &quot;1&quot;)]
    octaves: u8
}
</code></pre>
<pre><code class="language-diff">// src/lib.rs
  impl MusicMaker {
-     pub fn new() -&gt; Self
-         Self::default()
+     pub fn new(opt: Opt) -&gt; Self {
+         Self::default().set_base_note(opt.base_note).set_scale(opt.scale).set_octaves(opt.octaves)
      }
      fn get_frequency(&amp;mut self) -&gt; Sample {
          let pitch = Pitch::from(self.current_note);
          pitch.into()
      }
      fn new_note(&amp;mut self) {
          let keys = self.key.all_keys();
          self.current_note = *keys.iter().choose(&amp;mut self.seed).unwrap();
      }
+     fn set_base_note(mut self, base_note: Note) -&gt; Self {
+         self.key = Key::new(self.key.scale, &amp;base_note.to_string());
+         self
+     }
+     fn set_scale(mut self, scale: Scale) -&gt; Self {
+         self.key = Key::new(scale, &amp;self.key.base_note.to_string());
+         self
+     }
  }
</code></pre>
<p>We have to dispatch a few different paths now - replace <code>main()</code> with the following:</p>
<pre><code class="language-rust">fn main() {
    // Read arguments, greet user
    let opt = Opt::from_args();
    println!(&quot;{}&quot;, GREETING);

    // Set up audio playback
    let device = default_output_device().unwrap();
    let sink = Sink::new(&amp;device);

    // Define music source from Opt
    if opt.pitch_mode {
        let wave = SineWave::from(Pitch::from(opt.base_note));
        println!(&quot;Playing single tone {}&quot;, opt.base_note);
        // Play sine wave
        sink.append(wave);
    } else {
        // Init procedural generator
        let music = MusicMaker::new(opt.base_note, opt.scale, opt.octaves);
        println!(&quot;{}&quot;, music);
        // Play random melody
        sink.append(music);
    };
    // Sleep thread to allow music to play infinitely
    sink.sleep_until_end();
}
</code></pre>
<p>Make sure the code generation worked as expected with <code>cargo run -- -h</code> - you use <code>--</code> to pass command line arguments through <code>cargo run</code>, but you'd pass them directly to a binary: <code>./music -h</code>:</p>
<pre><code class="language-txt">$cargo run -- -h
    Finished dev [unoptimized + debuginfo] target(s) in 0.05s
     Running `target/debug/music -h`
music 0.1.0
music is a procedural single-tone melody generator

USAGE:
    music [FLAGS] [OPTIONS]

FLAGS:
    -h, --help          Prints help information
    -p, --pitch-mode    Single-pitch mode
    -V, --version       Prints version information

OPTIONS:
    -b, --base-note &lt;base-note&gt;    The base note to calculate the scale from [default: C4]
    -o, --octaves &lt;octaves&gt;        Number of octaves over which to range, anything over 8 gets parsed as 8 [default: 1]
    -s, --scale &lt;scale&gt;            The series of intervals from the base note to use per octave [default: Ionian]

</code></pre>
<p>Structopt is great for quick prototyping.  We should add an output line to the header to let the user know what's playing:</p>
<pre><code class="language-rust">impl fmt::Display for MusicMaker {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        let key = self.key;
        write!(
            f,
            &quot;Generating music from the {} {}\nOctaves: {} - {}\n{}&quot;,
            key.base_note.note,
            key.scale,
            key.base_note.octave,
            key.base_note.octave + key.octaves,
            key
        )
    }
}
</code></pre>
<p>Now we should see the current key at the top - both options are optional, and the default value will be used if not found:</p>
<pre><code class="language-txt">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.07s
     Running `target\debug\music.exe`
.: Cool Tunes :.
Generating music from the C major scale
Octaves: 4 - 5
[ C D E F G A B C ]
</code></pre>
<pre><code class="language-txt">$ cargo run -- -s chromatic
    Finished dev [unoptimized + debuginfo] target(s) in 0.07s
     Running `target\debug\music.exe -s chromatic`
.: Cool Tunes :.
Generating music from the C chromatic scale
Octaves: 4 - 5
[ C C# D D# E F F# G G# A A# B C ]
</code></pre>
<pre><code class="language-txt">$ cargo run -- -s locrian -b Eb3 -o 3
    Finished dev [unoptimized + debuginfo] target(s) in 0.07s
     Running `target\debug\music.exe -s locrian -b Eb2 -o 3`
.: Cool Tunes :.
Generating music from the E♭ Locrian mode
Octaves: 3 - 6
[ E♭ E F# G# A B C# E♭ ]
</code></pre>
<pre><code class="language-txt">$ cargo run -- -p -b C3
    Finished dev [unoptimized + debuginfo] target(s) in 0.07s
     Running `target\debug\music.exe -p -b C3`
Cool Tunes (tm)
.: Cool Tunes :.
Playing single tone C3
</code></pre>
<p>Check out C0 and A0, and be careful with headphones when getting to the upper octaves!</p>
<p><img src="https://thepracticaldev.s3.amazonaws.com/i/92xyu0xcenfmpvrf6kbq.gif" alt="human music" /></p>
<h2>Challenges</h2>
<p><em><a href="#table-of-contents">top</a></em></p>
<p>I wanted to keep this post to around an hour, but there are a number of ways this code could be extended:</p>
<ul>
<li>I can't even hear <code>C0</code> - can you?  Restrict the 108-key keyboard to the standard 88-key from the diagram, that only includes the top three notes of Octave 0 and the top note of Octave 8 (12 x 7 + 3 + 1).</li>
<li>Support even more types of key signatures like the <a href="https://en.wikipedia.org/wiki/Minor_scale#Harmonic_minor_scale">harmonic minor</a>, which is the Aeolian mode with the seventh note one semitone higher, or <a href="https://en.wikipedia.org/wiki/Pentatonic_scale">pentatonic scales</a>, which were hinted at above as using solely the black keys.  Those have modes too...</li>
<li>Generate those extended key signatures from strings like <code>&quot;Cmaj&quot;</code> or <code>&quot;Amin7&quot;</code>.</li>
<li>Let the user decide how long each note should sound.  Which part of <code>MusicMaker</code> do you think is responsible for that?</li>
<li>Support <a href="https://en.wikipedia.org/wiki/Helmholtz_pitch_notation">Helmholtz pitch notation</a>.</li>
<li>Instead of picking notes at random, support different kinds of seeds.  For instance, every file on your computer is a stream of bytes.  Maybe you could accept an <code>impl Iterator&lt;Item = u8&gt;</code>?</li>
<li>Support other types of wave forms than sines, such as square waves or sawtooth waves.</li>
<li>We can already read piano keys from strings like <code>&quot;D#4&quot;</code>.  Parse and play back predefined sequences of notes from text files.  This will involve some work: stacked accidentals, naturals, represent durations, etc.</li>
<li>A <a href="https://en.wikipedia.org/wiki/WAV"><code>WAV</code></a> file is an uncompressed audio stream, like the one we've built.  Write audio files containing your music with with <a href="https://github.com/ruuda/hound"><code>hound</code></a>.</li>
<li>Implement and play a <code>Chord</code>.</li>
<li>Port this program to another language.</li>
</ul>
<p>This has been a Public Service Announcement on the dangers of online encyclopedias.  Thank you for your time.</p>
<p><em>Cover image: <a href="https://www.reddit.com/r/linuxmasterrace/comments/dyqri7/like_god_would_have_wanted/">reddit</a></em></p>
</main>{% endblock %}
